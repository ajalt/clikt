package com.github.ajalt.clikt.completion

import com.github.ajalt.clikt.core.PrintCompletionMessage
import com.github.ajalt.clikt.core.subcommands
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.types.file
import com.github.ajalt.clikt.testing.TestCommand
import io.kotest.assertions.throwables.shouldThrow
import io.kotest.matchers.shouldBe
import org.junit.Rule
import kotlin.test.Test
import org.junit.contrib.java.lang.system.EnvironmentVariables

@UseExperimental(ExperimentalCompletionCandidates::class)
@Suppress("unused")
class CompletionTest {
    @Rule
    @JvmField
    val env = EnvironmentVariables()

    @Test
    fun `custom completions`() {
        env.set("TEST_COMPLETE", "true")
        class C : TestCommand(autoCompleteEnvvar = "TEST_COMPLETE") {
            val o by option(completionCandidates = CompletionCandidates.Custom.fromStdout("echo foo bar"))
            val a by argument(completionCandidates = CompletionCandidates.Custom {
                """
                WORDS=${'$'}(echo zzz xxx)
                COMPREPLY=(${'$'}(compgen -W "${'$'}WORDS" -- "${'$'}{COMP_WORDS[${'$'}COMP_CWORD]}"))
                """.trimIndent()
            })
        }
        shouldThrow<PrintCompletionMessage> {
            C().parse("")
        }.message shouldBe """
        |#!/usr/bin/env bash
        |# Command completion for c
        |# Generated by Clikt
        |
        |__skip_opt_eq() {
        |    # this takes advantage of the fact that bash functions can write to local
        |    # variables in their callers
        |    (( i = i + 1 ))
        |    if [[ "${'$'}{COMP_WORDS[${'$'}i]}" == '=' ]]; then
        |          (( i = i + 1 ))
        |    fi
        |}
        |
        |__c_complete___o() {
        |  COMPREPLY=(${'$'}(compgen -W "${'$'}(echo foo bar)" -- "${'$'}{COMP_WORDS[${'$'}COMP_CWORD]}"))
        |}
        |
        |__c_complete_A() {
        |  WORDS=${'$'}(echo zzz xxx)
        |  COMPREPLY=(${'$'}(compgen -W "${'$'}WORDS" -- "${'$'}{COMP_WORDS[${'$'}COMP_CWORD]}"))
        |}
        |
        |_c() {
        |  local i=1
        |  local in_param=''
        |  local fixed_arg_names=('A')
        |  local vararg_name=''
        |  local can_parse_options=1
        |
        |  while [[ ${'$'}{i} -lt ${'$'}COMP_CWORD ]]; do
        |    if [[ ${'$'}{can_parse_options} -eq 1 ]]; then
        |      case "${'$'}{COMP_WORDS[${'$'}i]}" in
        |        --)
        |          can_parse_options=0
        |          (( i = i + 1 ));
        |          continue
        |          ;;
        |        --o)
        |          __skip_opt_eq
        |          (( i = i + 1 ))
        |          [[ ${'$'}{i} -gt COMP_CWORD ]] && in_param='--o' || in_param=''
        |          continue
        |          ;;
        |        -h|--help)
        |          __skip_opt_eq
        |          in_param=''
        |          continue
        |          ;;
        |      esac
        |    fi
        |    case "${'$'}{COMP_WORDS[${'$'}i]}" in
        |      *)
        |        (( i = i + 1 ))
        |        # drop the head of the array
        |        fixed_arg_names=("${'$'}{fixed_arg_names[@]:1}")
        |        ;;
        |    esac
        |  done
        |  local word="${'$'}{COMP_WORDS[${'$'}COMP_CWORD]}"
        |  if [[ "${'$'}{word}" =~ ^[-] ]]; then
        |    COMPREPLY=(${'$'}(compgen -W '--o -h --help' -- "${'$'}{word}"))
        |    return
        |  fi
        |
        |  # We're either at an option's value, or the first remaining fixed size
        |  # arg, or the vararg if there are no fixed args left
        |  [[ -z "${'$'}{in_param}" ]] && in_param=${'$'}{fixed_arg_names[0]}
        |  [[ -z "${'$'}{in_param}" ]] && in_param=${'$'}{vararg_name}
        |
        |  case "${'$'}{in_param}" in
        |    --o)
        |       COMPREPLY=(${'$'}(compgen -F __c_complete___o 2>/dev/null))
        |      ;;
        |    --help)
        |      ;;
        |    A)
        |       COMPREPLY=(${'$'}(compgen -F __c_complete_A 2>/dev/null))
        |      ;;
        |  esac
        |}
        |
        |complete -F _c c
        """.trimMargin()
    }

    @Test
    fun `subcommands with multi-word names`() {
        env.set("TEST_COMPLETE", "true")
        class C : TestCommand(autoCompleteEnvvar = "TEST_COMPLETE")
        class Sub : TestCommand()
        class SubCommand : TestCommand(name = "sub-command")
        class LongSubCommand : TestCommand(name = "long-sub-command")

        shouldThrow<PrintCompletionMessage> {
            C().subcommands(Sub(), SubCommand().subcommands(LongSubCommand())).parse("")
        }.message shouldBe """
        |#!/usr/bin/env bash
        |# Command completion for c
        |# Generated by Clikt
        |
        |__skip_opt_eq() {
        |    # this takes advantage of the fact that bash functions can write to local
        |    # variables in their callers
        |    (( i = i + 1 ))
        |    if [[ "${"$"}{COMP_WORDS[${"$"}i]}" == '=' ]]; then
        |          (( i = i + 1 ))
        |    fi
        |}
        |
        |_c() {
        |  local i=1
        |  local in_param=''
        |  local fixed_arg_names=()
        |  local vararg_name=''
        |  local can_parse_options=1
        |
        |  while [[ ${"$"}{i} -lt ${"$"}COMP_CWORD ]]; do
        |    if [[ ${"$"}{can_parse_options} -eq 1 ]]; then
        |      case "${"$"}{COMP_WORDS[${"$"}i]}" in
        |        --)
        |          can_parse_options=0
        |          (( i = i + 1 ));
        |          continue
        |          ;;
        |        -h|--help)
        |          __skip_opt_eq
        |          in_param=''
        |          continue
        |          ;;
        |      esac
        |    fi
        |    case "${"$"}{COMP_WORDS[${"$"}i]}" in
        |      sub)
        |        _c_sub ${"$"}(( i + 1 ))
        |        return
        |        ;;
        |      sub-command)
        |        _c_sub_command ${"$"}(( i + 1 ))
        |        return
        |        ;;
        |      *)
        |        (( i = i + 1 ))
        |        # drop the head of the array
        |        fixed_arg_names=("${"$"}{fixed_arg_names[@]:1}")
        |        ;;
        |    esac
        |  done
        |  local word="${"$"}{COMP_WORDS[${"$"}COMP_CWORD]}"
        |  if [[ "${"$"}{word}" =~ ^[-] ]]; then
        |    COMPREPLY=(${"$"}(compgen -W '-h --help' -- "${"$"}{word}"))
        |    return
        |  fi
        |
        |  # We're either at an option's value, or the first remaining fixed size
        |  # arg, or the vararg if there are no fixed args left
        |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{fixed_arg_names[0]}
        |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{vararg_name}
        |
        |  case "${"$"}{in_param}" in
        |    --help)
        |      ;;
        |    *)
        |      COMPREPLY=(${"$"}(compgen -W 'sub sub-command' -- "${"$"}{word}"))
        |      ;;
        |  esac
        |}
        |
        |_c_sub() {
        |  local i=${"$"}1
        |  local in_param=''
        |  local fixed_arg_names=()
        |  local vararg_name=''
        |  local can_parse_options=1
        |
        |  while [[ ${"$"}{i} -lt ${"$"}COMP_CWORD ]]; do
        |    if [[ ${"$"}{can_parse_options} -eq 1 ]]; then
        |      case "${"$"}{COMP_WORDS[${"$"}i]}" in
        |        --)
        |          can_parse_options=0
        |          (( i = i + 1 ));
        |          continue
        |          ;;
        |        -h|--help)
        |          __skip_opt_eq
        |          in_param=''
        |          continue
        |          ;;
        |      esac
        |    fi
        |    case "${"$"}{COMP_WORDS[${"$"}i]}" in
        |      *)
        |        (( i = i + 1 ))
        |        # drop the head of the array
        |        fixed_arg_names=("${"$"}{fixed_arg_names[@]:1}")
        |        ;;
        |    esac
        |  done
        |  local word="${"$"}{COMP_WORDS[${"$"}COMP_CWORD]}"
        |  if [[ "${"$"}{word}" =~ ^[-] ]]; then
        |    COMPREPLY=(${"$"}(compgen -W '-h --help' -- "${"$"}{word}"))
        |    return
        |  fi
        |
        |  # We're either at an option's value, or the first remaining fixed size
        |  # arg, or the vararg if there are no fixed args left
        |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{fixed_arg_names[0]}
        |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{vararg_name}
        |
        |  case "${"$"}{in_param}" in
        |    --help)
        |      ;;
        |  esac
        |}
        |
        |_c_sub_command() {
        |  local i=${"$"}1
        |  local in_param=''
        |  local fixed_arg_names=()
        |  local vararg_name=''
        |  local can_parse_options=1
        |
        |  while [[ ${"$"}{i} -lt ${"$"}COMP_CWORD ]]; do
        |    if [[ ${"$"}{can_parse_options} -eq 1 ]]; then
        |      case "${"$"}{COMP_WORDS[${"$"}i]}" in
        |        --)
        |          can_parse_options=0
        |          (( i = i + 1 ));
        |          continue
        |          ;;
        |        -h|--help)
        |          __skip_opt_eq
        |          in_param=''
        |          continue
        |          ;;
        |      esac
        |    fi
        |    case "${"$"}{COMP_WORDS[${"$"}i]}" in
        |      long-sub-command)
        |        _c_sub_command_long_sub_command ${"$"}(( i + 1 ))
        |        return
        |        ;;
        |      *)
        |        (( i = i + 1 ))
        |        # drop the head of the array
        |        fixed_arg_names=("${"$"}{fixed_arg_names[@]:1}")
        |        ;;
        |    esac
        |  done
        |  local word="${"$"}{COMP_WORDS[${"$"}COMP_CWORD]}"
        |  if [[ "${"$"}{word}" =~ ^[-] ]]; then
        |    COMPREPLY=(${"$"}(compgen -W '-h --help' -- "${"$"}{word}"))
        |    return
        |  fi
        |
        |  # We're either at an option's value, or the first remaining fixed size
        |  # arg, or the vararg if there are no fixed args left
        |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{fixed_arg_names[0]}
        |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{vararg_name}
        |
        |  case "${"$"}{in_param}" in
        |    --help)
        |      ;;
        |    *)
        |      COMPREPLY=(${"$"}(compgen -W 'long-sub-command' -- "${"$"}{word}"))
        |      ;;
        |  esac
        |}
        |
        |_c_sub_command_long_sub_command() {
        |  local i=${"$"}1
        |  local in_param=''
        |  local fixed_arg_names=()
        |  local vararg_name=''
        |  local can_parse_options=1
        |
        |  while [[ ${"$"}{i} -lt ${"$"}COMP_CWORD ]]; do
        |    if [[ ${"$"}{can_parse_options} -eq 1 ]]; then
        |      case "${"$"}{COMP_WORDS[${"$"}i]}" in
        |        --)
        |          can_parse_options=0
        |          (( i = i + 1 ));
        |          continue
        |          ;;
        |        -h|--help)
        |          __skip_opt_eq
        |          in_param=''
        |          continue
        |          ;;
        |      esac
        |    fi
        |    case "${"$"}{COMP_WORDS[${"$"}i]}" in
        |      *)
        |        (( i = i + 1 ))
        |        # drop the head of the array
        |        fixed_arg_names=("${"$"}{fixed_arg_names[@]:1}")
        |        ;;
        |    esac
        |  done
        |  local word="${"$"}{COMP_WORDS[${"$"}COMP_CWORD]}"
        |  if [[ "${"$"}{word}" =~ ^[-] ]]; then
        |    COMPREPLY=(${"$"}(compgen -W '-h --help' -- "${"$"}{word}"))
        |    return
        |  fi
        |
        |  # We're either at an option's value, or the first remaining fixed size
        |  # arg, or the vararg if there are no fixed args left
        |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{fixed_arg_names[0]}
        |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{vararg_name}
        |
        |  case "${"$"}{in_param}" in
        |    --help)
        |      ;;
        |  esac
        |}
        |
        |complete -F _c c
        """.trimMargin()
    }

    @Test
    fun `explicit completion candidates`() {
        env.set("TEST_COMPLETE", "true")
        class C : TestCommand(autoCompleteEnvvar = "TEST_COMPLETE") {
            val o by option(completionCandidates = CompletionCandidates.Fixed("foo", "bar")).file()
            val a by argument(completionCandidates = CompletionCandidates.Fixed("baz", "qux")).file()
        }

        shouldThrow<PrintCompletionMessage> {
            C().parse("")
        }.message shouldBe """
        |#!/usr/bin/env bash
        |# Command completion for c
        |# Generated by Clikt
        |
        |__skip_opt_eq() {
        |    # this takes advantage of the fact that bash functions can write to local
        |    # variables in their callers
        |    (( i = i + 1 ))
        |    if [[ "${"$"}{COMP_WORDS[${"$"}i]}" == '=' ]]; then
        |          (( i = i + 1 ))
        |    fi
        |}
        |
        |_c() {
        |  local i=1
        |  local in_param=''
        |  local fixed_arg_names=('A')
        |  local vararg_name=''
        |  local can_parse_options=1
        |
        |  while [[ ${"$"}{i} -lt ${"$"}COMP_CWORD ]]; do
        |    if [[ ${"$"}{can_parse_options} -eq 1 ]]; then
        |      case "${"$"}{COMP_WORDS[${"$"}i]}" in
        |        --)
        |          can_parse_options=0
        |          (( i = i + 1 ));
        |          continue
        |          ;;
        |        --o)
        |          __skip_opt_eq
        |          (( i = i + 1 ))
        |          [[ ${"$"}{i} -gt COMP_CWORD ]] && in_param='--o' || in_param=''
        |          continue
        |          ;;
        |        -h|--help)
        |          __skip_opt_eq
        |          in_param=''
        |          continue
        |          ;;
        |      esac
        |    fi
        |    case "${"$"}{COMP_WORDS[${"$"}i]}" in
        |      *)
        |        (( i = i + 1 ))
        |        # drop the head of the array
        |        fixed_arg_names=("${"$"}{fixed_arg_names[@]:1}")
        |        ;;
        |    esac
        |  done
        |  local word="${"$"}{COMP_WORDS[${"$"}COMP_CWORD]}"
        |  if [[ "${"$"}{word}" =~ ^[-] ]]; then
        |    COMPREPLY=(${'$'}(compgen -W '--o -h --help' -- "${"$"}{word}"))
        |    return
        |  fi
        |
        |  # We're either at an option's value, or the first remaining fixed size
        |  # arg, or the vararg if there are no fixed args left
        |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{fixed_arg_names[0]}
        |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{vararg_name}
        |
        |  case "${"$"}{in_param}" in
        |    --o)
        |      COMPREPLY=(${'$'}(compgen -W 'foo bar' -- "${"$"}{word}"))
        |      ;;
        |    --help)
        |      ;;
        |    A)
        |      COMPREPLY=(${'$'}(compgen -W 'baz qux' -- "${"$"}{word}"))
        |      ;;
        |  esac
        |}
        |
        |complete -F _c c
        """.trimMargin()
    }

}
