package com.github.ajalt.clikt.completion

import com.github.ajalt.clikt.core.PrintCompletionMessage
import com.github.ajalt.clikt.core.PrintHelpMessage
import com.github.ajalt.clikt.core.subcommands
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.arguments.multiple
import com.github.ajalt.clikt.parameters.groups.OptionGroup
import com.github.ajalt.clikt.parameters.groups.cooccurring
import com.github.ajalt.clikt.parameters.groups.mutuallyExclusiveOptions
import com.github.ajalt.clikt.parameters.groups.provideDelegate
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.options.required
import com.github.ajalt.clikt.parameters.types.file
import com.github.ajalt.clikt.parameters.types.int
import com.github.ajalt.clikt.testing.TestCommand
import io.kotlintest.data.forall
import io.kotlintest.shouldBe
import io.kotlintest.shouldNotBe
import io.kotlintest.shouldThrow
import io.kotlintest.tables.row
import org.junit.Rule
import org.junit.Test
import org.junit.contrib.java.lang.system.EnvironmentVariables

class CompletionTest {
    @Rule
    @JvmField
    val env = EnvironmentVariables()

    @Test
    fun `explicit completion candidates`() {
        env.set("TEST_COMPLETE", "true")
        class C: TestCommand(autoCompleteEnvvar = "TEST_COMPLETE") {
            val o by option(completionCandidates = CompletionCandidates.Fixed("foo", "bar")).file()
            val a by argument(completionCandidates = CompletionCandidates.Fixed("baz", "qux")).file()
        }

        shouldThrow<PrintCompletionMessage> {
            C().parse("")
        }.message shouldBe """
        |#!/usr/bin/env bash
        |# Command completion for c
        |# Generated by Clikt
        |
        |__skip_opt_eq() {
        |    # this takes advantage of the fact that bash functions can write to local
        |    # variables in their callers
        |    (( i = i + 1 ))
        |    if [[ "${"$"}{COMP_WORDS[${"$"}i]}" == '=' ]]; then
        |          (( i = i + 1 ))
        |    fi
        |}
        |
        |_c() {
        |  local i=1
        |  local in_param=''
        |  local fixed_arg_names=('A')
        |  local vararg_name=''
        |  local can_parse_options=1
        |
        |  while [[ ${"$"}{i} -lt ${"$"}COMP_CWORD ]]; do
        |    if [[ ${"$"}{can_parse_options} -eq 1 ]]; then
        |      case "${"$"}{COMP_WORDS[${"$"}i]}" in
        |        --)
        |          can_parse_options=0
        |          (( i = i + 1 ));
        |          continue
        |          ;;
        |        --o)
        |          __skip_opt_eq
        |          (( i = i + 1 ))
        |          [[ ${"$"}{i} -gt COMP_CWORD ]] && in_param='--o' || in_param=''
        |          continue
        |          ;;
        |        -h|--help)
        |          __skip_opt_eq
        |          in_param=''
        |          continue
        |          ;;
        |      esac
        |    fi
        |    case "${"$"}{COMP_WORDS[${"$"}i]}" in
        |      *)
        |        (( i = i + 1 ))
        |        # drop the head of the array
        |        fixed_arg_names=("${"$"}{fixed_arg_names[@]:1}")
        |        ;;
        |    esac
        |  done
        |  local word="${"$"}{COMP_WORDS[${"$"}COMP_CWORD]}"
        |  if [[ "${"$"}{word}" =~ ^[-] ]]; then
        |    COMPREPLY=(${'$'}(compgen -W '--o -h --help' -- "${"$"}{word}"))
        |    return
        |  fi
        |
        |  # We're either at an option's value, or the first remaining fixed value
        |  # arg, or the vararg if there are no fixed args left
        |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{fixed_arg_names[0]}
        |  [[ -z "${"$"}{in_param}" ]] && in_param=${"$"}{vararg_name}
        |
        |  case "${"$"}{in_param}" in
        |    --o)
        |      COMPREPLY=(${'$'}(compgen -W 'foo bar' -- "${"$"}{word}"))
        |      ;;
        |    --help)
        |      ;;
        |    A)
        |      COMPREPLY=(${'$'}(compgen -W 'baz qux' -- "${"$"}{word}"))
        |      ;;
        |  esac
        |}
        |
        |complete -F _c c
        """.trimMargin()
    }

}
