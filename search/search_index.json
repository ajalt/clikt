{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Clikt (pronounced \u201cclicked\u201d) is a multiplatform Kotlin library that makes writing command line interfaces simple and intuitive. It\u2019s the \u201cCommand Line Interface for Kotlin\u201d.</p> <p>It is designed to make the process of writing command line tools effortless while supporting a wide variety of use cases and allowing advanced customization when needed.</p> <p>Clikt has:</p> <ul> <li>arbitrary nesting of commands</li> <li>composable, type safe parameter values</li> <li>generation of help output and shell autocomplete scripts</li> <li>multiplatform packages for JVM, NodeJS, and native Linux, Windows and MacOS </li> </ul> <p>What does it look like? Here\u2019s a complete example of a simple Clikt program:</p> <pre><code>class Hello : CliktCommand() {\nval count: Int by option(help=\"Number of greetings\").int().default(1)\nval name: String by option(help=\"The person to greet\").prompt(\"Your name\")\n\noverride fun run() {\nrepeat(count) {\necho(\"Hello $name!\")\n}\n}\n}\n\nfun main(args: Array&lt;String&gt;) = Hello().main(args)\n</code></pre> <p>And here\u2019s what it looks like when run:</p> <pre><code> $ ./hello --count=3\n Your name: John\n Hello John!\n Hello John!\n Hello John!\n</code></pre> <p>The help page is generated for you:</p> <pre><code>$ ./hello --help\nUsage: hello [OPTIONS]\n\nOptions:\n  --count INT  Number of greetings\n  --name TEXT  The person to greet\n  -h, --help   Show this message and exit\n</code></pre> <p>Errors are also taken care of:</p> <pre><code>$ ./hello --whoops\nUsage: hello [OPTIONS]\n\nError: no such option: \"--whoops\".\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Clikt is distributed through Maven Central.</p> <pre><code>dependencies {\nimplementation(\"com.github.ajalt.clikt:clikt:3.5.4\")\n}\n</code></pre>"},{"location":"#if-youre-using-maven-instead-of-gradle-use-artifactidclikt-jvmartifactid","title":"If you\u2019re using Maven instead of Gradle, use <code>&lt;artifactId&gt;clikt-jvm&lt;/artifactId&gt;</code>","text":""},{"location":"#multiplatform","title":"Multiplatform","text":"<p>Clikt supports the following targets: <code>jvm</code>, <code>mingwX64</code>, <code>linuxX64</code>, <code>macosX64</code>, and <code>js</code> (for both NodeJS and Browsers). Artifacts for macosArm64 are also published, but not tested with CI. See the docs for more information about functionality supported on each target. You\u2019ll need to use Gradle 6 or newer.</p>"},{"location":"#snapshots","title":"Snapshots","text":"Snapshot builds are also available <p> You'll need to add the Sonatype snapshots repository:   <pre><code>repositories {\nmaven {\nurl = uri(\"https://oss.sonatype.org/content/repositories/snapshots/\")\n}\n}\n</code></pre> </p>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Commands and Exceptions</li> <li>Options</li> <li>Arguments</li> <li>Parameter Type Conversions</li> <li>Output Formatting</li> </ul>"},{"location":"advanced/","title":"Advanced Patterns","text":""},{"location":"advanced/#common-options-with-subcommands","title":"Common Options With Subcommands","text":"<p>In some cases, you will have multiple subcommands that all share a common set of options. For example, you may have an option for a config file, or an output directory, or some API credentials. There are several ways to structure your commands to avoid repeating the option declarations in each subcommand.</p>"},{"location":"advanced/#defining-common-options-on-the-root-command","title":"Defining Common Options on the Root Command","text":"<p>You can define your options on the root command and pass down the information via the context. With this design, you\u2019ll have to specify the common options before the subcommand name on the command line.</p> ExampleUsage 1Usage 2 <pre><code>class Config(val token: String, val hostname: String)\n\nclass MyApi : CliktCommand() {\nprivate val token by option(help=\"api token to use for requests\").default(\"...\")\nprivate val hostname by option(help=\"base url for requests\").default(\"example.com\")\n\noverride fun run() {\ncurrentContext.obj = Config(token, hostname)\n}\n}\n\nclass Store : CliktCommand() {\nprivate val file by option(help=\"file to store\").file(canBeDir = false)\nprivate val config by requireObject&lt;Config&gt;()\noverride fun run() {\nmyApiStoreFile(config.token, config.hostname, file)\n}\n}\n\nclass Fetch : CliktCommand() {\nprivate val outdir by option(help=\"directory to store file in\").file(canBeFile = false)\nprivate val config by requireObject&lt;Config&gt;()\noverride fun run() {\nmyApiFetchFile(config.token, config.hostname, outdir)\n}\n}\n\nfun main(args: Array&lt;String&gt;) = MyApi().subcommands(Store(), Fetch()).main(args)\n</code></pre> <pre><code>$ ./myapi --hostname=https://example.com store file.txt\n</code></pre> <pre><code>$ ./myapi --hostname=https://example.com fetch --outdir=./out\n</code></pre>"},{"location":"advanced/#defining-common-options-in-a-group","title":"Defining Common Options in a Group","text":"<p>Instead of defining your common options on the root command, you can instead define them in an OptionGroup which you include in each subcommand. This allows you to specify all options after the subcommand name.</p> ExampleUsage 1Usage 2 <pre><code>class CommonOptions: OptionGroup(\"Standard Options:\") {\nval token by option(help=\"api token to use for requests\").default(\"...\")\nval hostname by option(help=\"base url for requests\").default(\"example.com\")\n}\n\nclass MyApi : NoOpCliktCommand()\n\nclass Store : CliktCommand() {\nprivate val commonOptions by CommonOptions()\nprivate val file by option(help=\"file to store\").file(canBeDir = false)\noverride fun run() {\nmyApiStoreFile(commonOptions.token, commonOptions.hostname, file)\n}\n}\n\nclass Fetch : CliktCommand() {\nprivate val commonOptions by CommonOptions()\nprivate val outdir by option(help=\"directory to store file in\").file(canBeFile = false)\noverride fun run() {\nmyApiFetchFile(commonOptions.token, commonOptions.hostname, outdir)\n}\n}\n\nfun main(args: Array&lt;String&gt;) = MyApi().subcommands(Store(), Fetch()).main(args)\n</code></pre> <pre><code>$ ./myapi store --hostname=https://example.com file.txt\n</code></pre> <pre><code>$ ./myapi fetch --hostname=https://example.com --outdir=./out\n</code></pre>"},{"location":"advanced/#defining-common-options-in-a-base-class","title":"Defining Common Options in a Base Class","text":"<p>A third design to share options is to define the common options in a base class that all the subcommands inherit from.</p> ExampleUsage 1Usage 2 <pre><code>abstract class MyApiSubcommand : CliktCommand() {\nval token by option(help = \"api token to use for requests\").default(\"...\")\nval hostname by option(help = \"base url for requests\").default(\"example.com\")\n}\n\nclass MyApi : NoOpCliktCommand()\n\nclass Store : MyApiSubcommand() {\nprivate val file by option(help = \"file to store\").file(canBeDir = false)\noverride fun run() {\nmyApiStoreFile(token, hostname, file)\n}\n}\n\nclass Fetch : MyApiSubcommand() {\nprivate val outdir by option(help = \"directory to store file in\").file(canBeFile = false)\noverride fun run() {\nmyApiFetchFile(token, hostname, outdir)\n}\n}\n\nfun main(args: Array&lt;String&gt;) = MyApi().subcommands(Store(), Fetch()).main(args)\n</code></pre> <pre><code>$ ./myapi store --hostname=https://example.com file.txt\n</code></pre> <pre><code>$ ./myapi fetch --hostname=https://example.com --outdir=./out\n</code></pre>"},{"location":"advanced/#command-aliases","title":"Command Aliases","text":"<p>Clikt allows commands to alias command names to sequences of tokens. This allows you to implement common patterns like allowing the user to invoke a command by typing a prefix of its name, or user-defined aliases like the way you can configure git to accept <code>git ci</code> as an alias for <code>git commit</code>.</p> <p>To implement command aliases, override <code>CliktCommand.aliases</code> in your command. This function is called once at the start of parsing, and returns a map of aliases to the tokens that they alias to.</p> <p>To implement git-style aliases:</p> ExampleUsage 1Usage 2 <pre><code>class Repo : NoOpCliktCommand() {\n// You could load the aliases from a config file etc.\noverride fun aliases(): Map&lt;String, List&lt;String&gt;&gt; = mapOf(\n\"ci\" to listOf(\"commit\"),\n\"cm\" to listOf(\"commit\", \"-m\")\n)\n}\n\nclass Commit: CliktCommand() {\nval message by option(\"-m\").default(\"\")\noverride fun run() {\necho(\"Committing with message: $message\")\n}\n}\n\nfun main(args: Array&lt;String&gt;) = Repo().subcommands(Commit()).main(args)\n</code></pre> <pre><code>$ ./repo ci -m 'my message'\nCommitting with message: my message\n</code></pre> <pre><code>$ ./repo cm 'my message'\nCommitting with message: my message\n</code></pre> <p>Note that aliases are not expanded recursively: none of the tokens that an alias expands to will be expanded again, even if they match another alias.</p> <p>You also use this functionality to implement command prefixes:</p> ExampleUsage <pre><code>class Tool : NoOpCliktCommand() {\noverride fun aliases(): Map&lt;String, List&lt;String&gt;&gt; {\nval prefixCounts = mutableMapOf&lt;String, Int&gt;().withDefault { 0 }\nval prefixes = mutableMapOf&lt;String, List&lt;String&gt;&gt;()\nfor (name in registeredSubcommandNames()) {\nif (name.length &lt; 3) continue\nfor (i in 1..name.lastIndex) {\nval prefix = name.substring(0..i)\nprefixCounts[prefix] = prefixCounts.getValue(prefix) + 1\nprefixes[prefix] = listOf(name)\n}\n}\nreturn prefixes.filterKeys { prefixCounts.getValue(it) == 1 }\n}\n}\n\nclass Foo: CliktCommand() {\noverride fun run() {\necho(\"Running Foo\")\n}\n}\n\nclass Bar: CliktCommand() {\noverride fun run() {\necho(\"Running Bar\")\n}\n}\n\nfun main(args: Array&lt;String&gt;) = Tool().subcommands(Foo(), Bar()).main(args)\n</code></pre> <pre><code>$ ./tool ba\nRunning Bar\n</code></pre>"},{"location":"advanced/#token-normalization","title":"Token Normalization","text":"<p>To prevent ambiguities in parsing, aliases are only supported for command names. However, there\u2019s another way to modify user input that works on more types of tokens. You can set a <code>tokenTransformer</code> on the command\u2019s context that will be called for each option and command name that is input. This can be used to implement case-insensitive parsing, for example:</p> ExampleUsage <pre><code>class Hello : CliktCommand() {\ninit {\ncontext { tokenTransformer = { it.lowercase() } }\n}\n\nval name by option()\noverride fun run() = echo(\"Hello $name!\")\n}\n</code></pre> <pre><code>$ ./hello --NAME=Foo\nHello Foo!\n</code></pre>"},{"location":"advanced/#replacing-stdin-and-stdout","title":"Replacing stdin and stdout","text":"<p>By default, functions like <code>CliktCommand.main</code> and <code>option().prompt()</code> read from <code>System.in</code> and write to <code>System.out</code>. If you want to use clikt in an environment where the standard streams aren\u2019t available, you can set your own implementation of <code>CliktConsole</code> when customizing the command context.</p> <pre><code>object MyConsole : CliktConsole {\noverride fun promptForLine(prompt: String, hideInput: Boolean): String? {\nMyOutputStream.write(prompt)\nreturn if (hideInput) MyInputStream.readPassword()\nelse MyInputStream.readLine()\n}\n\noverride fun print(text: String, error: Boolean) {\nif (error) MyOutputStream.writeError(prompt)\nelse MyOutputStream.write(prompt)\n}\n\noverride val lineSeparator: String get() = \"\\n\"\n}\n\nclass CustomCLI : NoOpCliktCommand() {\ninit { context { console = MyConsole } }\n}\n</code></pre>"},{"location":"advanced/#command-line-argument-files-argfiles","title":"Command Line Argument Files (\u201c@argfiles\u201d)","text":"<p>Similar to <code>javac</code>, Clikt supports loading command line parameters from a file using the \u201c@argfile\u201d syntax. You can pass any file path to a command prefixed with <code>@</code>, and the file will be expanded into the command line parameters. This can be useful on operating systems like Windows that have command line length limits.</p> <p>If you create a file named <code>cliargs</code> with content like this:</p> <pre><code>--number 1\n--name='jane doe' --age=30\n./file.txt\n</code></pre> <p>You can call your command with the contents of the file like this:</p> <pre><code>$ ./tool @cliargs\n</code></pre> <p>Which is equivalent to calling it like this:</p> <pre><code>$ ./tool --number 1 --name='jane doe' --age=30 ./file.txt\n</code></pre> <p>You can use any file path after the <code>@</code>, and can specify multiple @argfiles:</p> <pre><code>$ ./tool @../config/args @C:\\\\Program\\ Files\\\\Tool\\\\argfile\n</code></pre> <p>If you have any options with names that start with <code>@</code>, you can still use <code>@argfiles</code>, but values on the command line that match an option will be parsed as that option, rather than an <code>@argfile</code>, so you\u2019ll have to give your files a different name.</p>"},{"location":"advanced/#preventing-argfile-expansion","title":"Preventing @argfile expansion","text":"<p>If you want to use a value starting with <code>@</code> as an argument without expanding it, you have three options:</p> <ol> <li>Pass it after a <code>--</code>, which disables expansion for everything that occurs after it.</li> <li>Escape it with <code>@@</code>. The first <code>@</code> will be removed and the rest used as the argument value. For example, <code>@@file</code> will parse as the string <code>@file</code></li> <li>Disable @argfile expansion entirely by setting <code>Context.expandArgumentFiles = false</code></li> </ol>"},{"location":"advanced/#file-format","title":"File format","text":"<ul> <li>Normal shell quoting and escaping rules apply. </li> <li>Line breaks are treated as word separators, and can be used where you would normally use a space   to separate parameters.</li> <li>Line breaks can occur within quotes, and will be included in the quoted value.</li> <li>@argfiles can contain other @argfile arguments, which will be expanded recursively.</li> <li>An unescaped <code>#</code> character outside of quotes is treated as a line comment: it and the rest of the   line are skipped. You can pass a literal <code>#</code> by escaping it with <code>\\#</code> or quoting it with <code>'#'</code>.</li> <li>If a <code>\\</code> occurs at the end of a line, the next line is trimmed of leading whitespace and the two   lines are concatenated.</li> </ul>"},{"location":"advanced/#testing-your-clikt-cli","title":"Testing your Clikt CLI","text":"<p><code>CliktCommand.main</code> calls <code>exitProcess</code> when invalid values are provided on the command line. In unit tests, you should instead call <code>CliktCommand.parse</code>, which throws exceptions with error details rather than printing the details and exiting the process. See the documentation on exceptions for more information.</p> <p>If your command uses environment variables, you can set a function on the context that returns test values.</p>"},{"location":"advanced/#custom-exit-status-codes","title":"Custom exit status codes","text":"<p>Clikt will normally exit your program with a status code of 0 for a normal execution, or 1 if there\u2019s an error. If you want to use a different value, you can <code>throw ProgramResult(statusCode)</code>. If you use <code>CliktCommand.main</code>, that exception will be caught and <code>exitProcess</code> will be called with the value of <code>statusCode</code>.</p> <p>You could also call <code>exitProcess</code> yourself, but the ProgramResult has a couple of advantages:</p> <ul> <li><code>ProgramResult</code> is easier to test. Exiting the process makes unit tests difficult to run.</li> <li><code>ProgramResult</code> works on all platforms. <code>exitProcess</code> is only available on the JVM.</li> </ul>"},{"location":"advanced/#multiplatform-support","title":"Multiplatform Support","text":"<p>Clikt supports the following platforms in addition to JVM:</p>"},{"location":"advanced/#desktop-native-linux-windows-and-macos","title":"Desktop native (Linux, Windows, and MacOS)","text":"<p>All functionality is supported, except:</p> <ul> <li><code>env</code> parameter of editText and editFile is ignored.</li> <li><code>hideInput</code> parameter of prompt is ignored.</li> <li>file and path parameter types are not supported.</li> </ul>"},{"location":"advanced/#nodejs","title":"NodeJS","text":"<p>All functionality is supported, except:</p> <ul> <li><code>hideInput</code> parameter of prompt is ignored.</li> <li>file and path parameter types are not supported.</li> </ul>"},{"location":"advanced/#browser-javascript","title":"Browser JavaScript","text":"<p>All functionality is supported, except:</p> <ul> <li>The default CliktConsole only outputs to the browser\u2019s developer console, which is probably not what you want. You can define your own CliktConsole, or you can call parse instead of main and handle output yourself.</li> <li>editText and editFile are not supported.</li> <li>prompt is only supported if you define your own CliktConsole.</li> <li>file and path parameter types are not supported.</li> </ul>"},{"location":"arguments/","title":"Arguments","text":"<p>Arguments are declared and customized similarly to options, but are provided on the command line positionally instead of by name. Arguments are declared with <code>argument()</code>, and the order that they are declared defines the order that they must be provided on the command line.</p>"},{"location":"arguments/#basic-arguments","title":"Basic Arguments","text":"<p>By default, <code>argument</code> takes a single <code>String</code> value which is required to be provided on the command line.</p> ExampleUsage <pre><code>class Hello : CliktCommand() {\nval name by argument()\noverride fun run() {\necho(\"Hello $name!\")\n}\n}\n</code></pre> <pre><code>$ ./hello Foo\nHello Foo!\n</code></pre> <p>Arguments appear in the usage string, but normally aren\u2019t listed in the help page. It\u2019s usually more clear to document arguments in the command help.</p> ExampleHelp Output <pre><code>class Cp : CliktCommand(help = \"Copy SOURCE to DEST, or multiple SOURCE(s) to directory DEST.\") {\nprivate val source by argument().file(mustExist = true).multiple()\nprivate val dest by argument().file()\noverride fun run() {\n// ...\n}\n}\n</code></pre> <pre><code>Usage: cp [OPTIONS] [SOURCE]... DEST\n\n  Copy SOURCE to DEST, or multiple SOURCE(s) to directory DEST.\n\nOptions:\n  -h, --help         Show this message and exit\n</code></pre>"},{"location":"arguments/#variadic-arguments","title":"Variadic Arguments","text":"<p>Like options, arguments can take any fixed number of values, which you can change with functions like <code>pair</code> and <code>triple</code>. Unlike options, arguments can also take a variable (or unlimited) number of values. This is common with file path arguments, since they are frequently expanded with a glob pattern on the command line.</p> <p>Variadic arguments are declared with <code>multiple</code>. You can declare any number of arguments with fixed numbers of values, but only one variadic argument in a command.</p> ExampleUsage <pre><code>class Copy : CliktCommand() {\nval source: List&lt;Path&gt; by argument().path(mustExist = true).multiple()\nval dest: Path by argument().path(canBeFile = false)\noverride fun run() {\necho(\"Copying files $source to $dest\")\n}\n}\n</code></pre> <pre><code>$ ./copy file.* out/\nCopying files [file.txt, file.md] to out/\n</code></pre> <p>You can also use <code>unique</code> to discard duplicates:</p> <pre><code>val source: Set&lt;Path&gt; by argument().path(mustExist = true).multiple().unique()\n</code></pre>"},{"location":"arguments/#option-like-arguments-using-","title":"Option-Like Arguments (Using <code>--</code>)","text":"<p>Clikt normally parses any value that starts with punctuation as an option, which allows users to intermix options and arguments. However, sometimes you need to pass a value that starts with punctuation to an argument. For example, you might have a file named <code>-file.txt</code> that you want to use as an argument.</p> <p>Clikt supports the POSIX convention of using <code>--</code> to force all following values to be treated as arguments. Any values before the <code>--</code> will be parsed normally.</p> ExampleUsage 1Usage 2 <pre><code>class Touch : CliktCommand() {\nval verbose by option().flag()\nval files by argument().multiple()\noverride fun run() {\nif (verbose) echo(files.joinToString(\"\\n\"))\n}\n}\n</code></pre> <pre><code>$ ./touch --foo.txt\nUsage: touch [OPTIONS] [FILES]...\n\nError: no such option: \"--foo.txt\".\n</code></pre> <pre><code>$ ./touch --verbose -- --foo.txt bar.txt\n--foo.txt\nbar.txt\n</code></pre>"},{"location":"autocomplete/","title":"Shell Autocomplete","text":"<p>Clikt includes built-in support for generating autocomplete scripts for bash, zsh and fish shells.</p> Example <pre><code>$ ./repo &lt;TAB&gt;&lt;TAB&gt;\ncommit clone pull\n\n$ ./repo -&lt;TAB&gt;\n--config -h --help --repo-home --verbose\n\n$./repo --repo-home ./g&lt;TAB&gt;\n./git ./got ./good\n</code></pre>"},{"location":"autocomplete/#enabling-completion","title":"Enabling Completion","text":"<p>Clikt handles autocomplete by generating a shell script that defines the completion. You generate the script once each time your CLI changes, and load it each time your start your shell. </p>"},{"location":"autocomplete/#with-an-environment-variable","title":"With an environment variable","text":"<p>You can generate the completion script by invoking your program with a special environment variable.</p> <p>You can set the variable name manually with the <code>autoCompleteEnvvar</code> parameter in the <code>CliktCommand</code> constructor. By default it\u2019s your command\u2019s name capitalized, with <code>-</code> replaced with <code>_</code>, and prefixed with another <code>_</code>. So if your command name is <code>my-command</code>, the variable would be <code>_MY_COMMAND_COMPLETE=bash</code>,  <code>_MY_COMMAND_COMPLETE=zsh</code>, or <code>_MY_COMMAND_COMPLETE=fish</code>, depending on your current shell.</p> <p>For example to activate bash autocomplete for this command:</p> <pre><code>class MyProgram: CliktCommand() {\n// ...\n}\n</code></pre> <p>You can generate the completion script and save it to a file like this:</p> <pre><code>$ _MY_PROGRAM_COMPLETE=bash ./my-program &gt; ~/my-program-completion.sh\n</code></pre>"},{"location":"autocomplete/#with-an-option","title":"With an option","text":"<p>If you\u2019d prefer not to use environment variables, you can add a special option to your command with the <code>completionOption</code> function. Invoking your program with this option will generate the completion script:</p> Example 1Example 2Usage <pre><code>class MyCommand: CliktCommand() {\ninit {\ncompletionOption()\n}\n// ...\n}\n</code></pre> <pre><code>class MyCommand: CliktCommand() {\n//..\n}\n\nfun main(args: Array&lt;String&gt;) = MyCommand().completionOption().main(args)\n</code></pre> <pre><code>$ ./my-command --generate-completion=bash &gt; ~/my-program-completion.sh\n</code></pre>"},{"location":"autocomplete/#with-a-subcommand","title":"With a subcommand","text":"<p>A third option is to add a subcommand that will generate the completion when invoked.</p> Example 1Example 2Usage <pre><code>class MyCommand: CliktCommand() {\ninit {\nsubcommands(CompletionCommand())\n}\n// ...\n}\n</code></pre> <pre><code>class MyCommand: CliktCommand() {\n//..\n}\n\nfun main(args: Array&lt;String&gt;) = MyCommand().subcommands(CompletionCommand()).main(args)\n</code></pre> <pre><code>$ ./my-command generate-completion bash &gt; ~/my-program-completion.sh\n</code></pre>"},{"location":"autocomplete/#using-the-generated-script","title":"Using the generated script","text":"<p>Once you\u2019ve generated the completion script, source the file to activate completion:</p> <pre><code>$ source ~/my-program-completion.sh\n</code></pre> <p>You can add that source command to your startup script so that completion is always available. For example, with bash:</p> <pre><code>$ echo source ~/my-program-completion.sh &gt;&gt; ~/.bashrc\n</code></pre> <p>You\u2019ll need to regenerate the completion script any time your command structure changes.</p>"},{"location":"autocomplete/#supported-functionality","title":"Supported Functionality","text":""},{"location":"autocomplete/#bash-and-zsh","title":"Bash and Zsh","text":"<p>Currently subcommand, option, and command alias names can be completed, as well as values for options and arguments. <code>choice</code> parameters are completed with their possible values. Other parameter types are completed as file or directory names. <code>Context.allowInterspersedArgs</code> is supported.</p>"},{"location":"autocomplete/#fish","title":"Fish","text":"<p>Fish\u2019s completion mechanism is more limited that Bash\u2019s. Subcommands can be completed, options can be completed as long as they start with a <code>-</code>. Completion suggestions for positional arguments are the union of all positional arguments. Other advanced Clikt features are not supported. </p>"},{"location":"autocomplete/#customizing-completions","title":"Customizing Completions","text":"<p>There is built-in completion for values for <code>choice</code> parameters, and for parameters converted with <code>file</code> and <code>path</code>.</p> <p>You can add completion for other parameters with the <code>completionCandidates</code> parameter to <code>option()</code> and <code>argument()</code>. The value can be one of the following:</p> <ul> <li><code>None</code>: The default. The parameter\u2019s values will not be completed.</li> <li><code>Path</code>: Completions will be filesystem paths.</li> <li><code>Hostname</code>: Completions will be read from the system\u2019s hosts file.</li> <li><code>Username</code>: Completions will be taken from the system\u2019s users.</li> <li><code>Fixed</code>: Completions are given as a fixed set of strings.</li> <li><code>Custom</code>: Completions are generated from a custom script.</li> </ul>"},{"location":"autocomplete/#custom-completion-candidates","title":"<code>Custom</code> completion candidates","text":"<p>The <code>Custom</code> type takes a block that returns code to add to the script which generates completions for the given parameter.</p> <p>If you just want to call another script or binary that prints all possible completion words to stdout, you can use fromStdout.</p> <p>Both Bash and ZSH scripts use Bash\u2019s Programmable Completion system (ZSH via a comparability layer). The string returned from [generator] should be the body of a function that will be passed to <code>compgen -F</code>.</p> <p>Specifically, you should set the variable <code>COMPREPLY</code> to the completion(s) for the current word being typed. The word being typed can be retrieved from the <code>COMP_WORDS</code> array at index <code>COMP_CWORD</code>.</p> Example with fromStdoutExample with full script <pre><code>class Hello: CliktCommand() {\n// This example uses `echo`, but you would use your own binary\n// or script that prints the completions.\nval name by option(completionCandidates =\nCompletionCandidates.Custom.fromStdout(\"echo completion1 completion2\")\n)\noverride fun run() {\necho(\"Hello, $name!\")\n}\n}\n</code></pre> <pre><code>class Hello: CliktCommand() {\n// This is identical to the previous example\nval name by option(completionCandidates = CompletionCandidates.Custom {\n\"\"\"\n        WORDS=${'$'}(echo completion1 completion2)\n        COMPREPLY=(${'$'}(compgen -W \"${'$'}WORDS\" -- \"${'$'}{COMP_WORDS[${'$'}COMP_CWORD]}\"))\n        \"\"\".trimIndent()\n})\noverride fun run() {\necho(\"Hello, $name!\")\n}\n}\n</code></pre>"},{"location":"autocomplete/#limitations","title":"Limitations","text":"<p>Token Normalization is not supported.</p> <p>If you have arguments that occur after a <code>multiple</code> argument, those arguments won\u2019t be autocompleted. Partial command lines are ambiguous in those situations, and Clikt assumes that you\u2019re trying to complete the <code>multiple</code> argument rather than the later ones.</p> <p>Bash must be at least version 3, or Zsh must be at least version 4.1.</p>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#354","title":"3.5.4","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Revert jvm jars to target Java 8</li> </ul>"},{"location":"changelog/#353","title":"3.5.3","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Updated Kotlin to 1.8.22</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Context is now set properly on NoSuchOption exceptions when thrown from subcommands. (#399)</li> <li>When <code>treatUnknownOptionsAsArgs</code> is true, grouped unknown short options will now be treated as arguments rather than reporting an error.</li> </ul>"},{"location":"changelog/#352","title":"3.5.2","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Updated Kotlin to 1.8.10</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fix <code>CliktCommand.prompt</code> on NodeJS targets that would hang due to KT-55817 (#387)</li> </ul>"},{"location":"changelog/#351","title":"3.5.1","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Updated Kotlin to 1.7.20</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Support unicode in environment variable values on Native Windows. (#362)</li> <li>Support environment variables for options in a mutually exclusive options group. (#384)</li> </ul>"},{"location":"changelog/#350","title":"3.5.0","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Added <code>hidden</code> parameter to <code>CliktCommand</code>, which will prevent the command from being displayed as a subcommand in help output  (#353)</li> <li>Publish artifacts for the <code>macosArm64</code> target. Note that this target is not tested on CI. (#352)</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Default values for arguments will now be included in help output when <code>showDefaultValues=true</code> is set on your help formatter (#357)</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Fix flags and other options with defaults not being usable in <code>mutuallyExclusiveOptions</code> (#349)</li> <li>Fix <code>CompletionCommand</code> generating completion for itself (#355)</li> </ul>"},{"location":"changelog/#342","title":"3.4.2","text":""},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li><code>TermUi.echo</code>, <code>TermUi.prompt</code>, and <code>TermUi.confirm</code>. Use the equivalent methods on <code>CliktCommand</code> instead. (#344)</li> </ul>"},{"location":"changelog/#341","title":"3.4.1","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Publish JS artifacts with new IR compiler, in addition to the legacy format </li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Updated Kotlin to 1.6.20</li> </ul>"},{"location":"changelog/#340","title":"3.4.0","text":""},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li><code>unique()</code> now works with any option with a list type, not just <code>multiple()</code> options (#332)</li> <li>Updated Kotlin to 1.6.10</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Fixed co-occurring option groups returning null when all options in the group are defined in environment variables (#330)</li> </ul>"},{"location":"changelog/#330","title":"3.3.0","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Added <code>default</code> parameter to <code>argument().multiple()</code> (#305)</li> <li><code>Context.originalArgv</code> that allows you to read the command line arguments from within a command\u2019s <code>run</code> (#290)</li> <li><code>context { envarReader = {...} }</code> to set a custom function to read from environment variables (#299)</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li><code>defaultLazy</code> values can now reference other parameters, as long the referenced parameters do not also reference other parameters</li> <li>You can now call <code>CliktCommand.context</code> multiple times on the same command, and all builder blocks will be applied </li> <li>Validate values entered to a <code>prompt</code> option, and show another prompt if the validation fails (#288)</li> <li>Updated kotlin to 1.5.31</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Report error when excess arguments are given to a command with <code>allowMultipleSubcommands=true</code> (#303)</li> </ul>"},{"location":"changelog/#320","title":"3.2.0","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li><code>InputStream.isCliktParameterDefaultStdin</code> and <code>OutputStream.isCliktParameterDefaultStdout</code> to check if the streams returned from <code>inputStream</code>/<code>outputStream</code> options are proxying stdin/stdout (#272)</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Make parameters of <code>mutuallyExclusiveOptions</code> covariant to allow validation without explicit type annotations. (#265)</li> <li>Updated kotlin to 1.5.0</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Reading from an option or argument property on a command that hasn\u2019t been invoked will now always throw an <code>IllegalStateException</code></li> </ul>"},{"location":"changelog/#310","title":"3.1.0","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Added <code>required()</code> and <code>defaultLazy()</code> for nullable flag options like <code>switch()</code>. (#240)</li> <li>Added support for generating autocomplete scripts for Fish shells (#189)</li> <li>Added <code>CompletionCommand</code> and <code>CliktCommand.completionOption()</code> that will print an autocomplete script when invoked, as an alternative to using environment variables.</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Updated Kotlin to 1.4.21</li> <li><code>@argfiles</code> now allow line breaks in quoted values, which are included in the value verbatim. You can now end lines with <code>\\</code> to concatenate them with the following line. (#248)</li> </ul>"},{"location":"changelog/#301","title":"3.0.1","text":""},{"location":"changelog/#deprecated_1","title":"Deprecated","text":"<ul> <li>Deprecated calling <code>echo</code> with <code>err</code> or <code>lineSeparator</code> but no <code>message</code>. </li> </ul>"},{"location":"changelog/#300","title":"3.0.0","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Clikt\u2019s JS target now supports both NodeJS and Browsers. (#198)</li> <li>Default values for switch options are now shown in the help. Help text can be customized using the <code>defaultForHelp</code> argument, similar to normal options. (#205)</li> <li>Added <code>FlagOption.convert</code> (#208)</li> <li>Added ability to use unicode NEL character (<code>\\u0085</code>) to manually break lines in help output (#214)</li> <li>Added <code>help(\"\")</code> extension to options and arguments as an alternative to passing the help as an argument (#207)</li> <li>Added <code>valueSourceKey</code> parameter to <code>option</code></li> <li>Added <code>check()</code> extensions to options and arguments as an alternative to <code>validate()</code></li> <li>Added <code>prompt</code> and <code>confirm</code> functions to <code>CliktCommand</code> that call the <code>TermUi</code> equivalents with the current console.</li> <li>Added <code>echo()</code> overload with no parameters to CliktCommand that prints a newline by itself.</li> <li>Added localization support. You can set an implementation of the <code>Localization</code> interface on your context with your translations. (#227)</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Hidden options will no longer be suggested as possible typo corrections. (#202)</li> <li>Options and Arguments with <code>multiple(required=true)</code> will now show as required in help output. (#212)</li> <li>Multiple short lines in a help text paragraph no longer appear dedented (#215)</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Updated Kotlin to 1.4.0</li> <li><code>Argument.help</code> and <code>Option.help</code> properties have been renamed to <code>argumentHelp</code> and <code>optionHelp</code>, respectively. The <code>help</code> parameter names to <code>option()</code> and <code>argument()</code> are unchanged.</li> <li><code>commandHelp</code> and <code>commandHelpEpilog</code> properties on <code>CliktCommand</code> are now <code>open</code>, so you can choose to override them instead of passing <code>help</code> and <code>epilog</code> to the constructor.</li> <li>Replaced <code>MapValueSource.defaultKey</code> with <code>ValueSource.getKey()</code>, which is more customizable.</li> <li><code>Option.metavar</code>, <code>Option.parameterHelp</code>, <code>OptionGroup.parameterHelp</code> and <code>Argument.parameterHelp</code> properties are now functions.</li> <li>Changed constructor parameters of <code>CliktHelpFormatter</code>. Added <code>localization</code> and removed <code>usageTitle</code>, <code>optionsTitle</code>, <code>argumentsTitle</code>, <code>commandsTitle</code>, <code>optionsMetavar</code>, and <code>commandMetavar</code>. Those strings are now defined on equivalently named functions on <code>Localization</code>.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Removed <code>envvarSplit</code> parameter from <code>option()</code> and <code>convert()</code>. Option values from environment variables are no longer split automatically. (#177)</li> <li>Removed public constructors from the following classes: <code>ProcessedArgument</code>, <code>OptionWithValues</code>, <code>FlagOption</code>, <code>CoOccurringOptionGroup</code>, <code>ChoiceGroup</code>, <code>MutuallyExclusiveOptions</code>.</li> <li><code>MissingParameter</code> exception replaced with <code>MissingOption</code> and <code>MissingArgument</code></li> <li>Removed <code>Context.helpOptionMessage</code>. Override <code>Localization.helpOptionMessage</code> and set it on your context instead.</li> </ul>"},{"location":"changelog/#deprecated_2","title":"Deprecated","text":"<ul> <li><code>@ExperimentalCompletionCandidates</code> and <code>@ExperimentalValueSourceApi</code> annotations. These APIs no longer require an opt-in.</li> </ul>"},{"location":"changelog/#280","title":"2.8.0","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Added <code>error</code> parameter to <code>PrintMessage</code> and <code>PrintHelpMessage</code>. When <code>true</code>, <code>CliktCommand.main</code> will exit with status code 1. (#187)</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>When <code>printHelpOnEmptyArgs</code> is <code>true</code> and no arguments are present, or when <code>invokeWithoutSubcommand</code> is <code>false</code> and no subcommand is present, <code>CliktCommand.main</code> will now exit with status code 1 rather than 0. </li> <li><code>restrictTo</code> now works with any <code>Comparable</code> value, not just <code>Number</code>.</li> <li><code>CliktCommand.main</code> now accepts <code>Array&lt;out String&gt;</code>, not just <code>Array&lt;String&gt;</code>. (#196)</li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Fixed option values being reset when calling multiple subcommands with <code>allowMultipleSubcommands=true</code> (#190)</li> </ul>"},{"location":"changelog/#271","title":"2.7.1","text":""},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>Fixed NPE thrown in some cases when using <code>defaultByName</code> (#179)</li> </ul>"},{"location":"changelog/#270","title":"2.7.0","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Ability to use custom program exit status codes via <code>ProgramResult</code>.</li> <li><code>inputStream</code> and <code>outputStream</code> conversions for options and arguments. (#157 and #159)</li> <li><code>splitPair</code>, <code>toMap</code>, and <code>associate</code> extensions on <code>option</code>. (#166)</li> <li><code>treatUnknownOptionsAsArgs</code> parameter to <code>CliktCommand</code>. (#152)</li> <li><code>defaultByName</code> function for <code>groupChoice</code> and <code>groupSwitch</code> options. (#171)</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>Update Kotlin to 1.3.71</li> <li>Improved command name inference. Now, a class like <code>MyAppCommand</code> will infer its <code>commandName</code> as <code>my-app</code> rather than <code>myappcommand</code>. You can still specify the name manually as before. ([#168][https://github.com/ajalt/clikt/pull/168])</li> </ul>"},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Correctly parse short options with attached values that contain <code>=</code></li> </ul>"},{"location":"changelog/#260","title":"2.6.0","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li><code>registeredSubcommands</code>, <code>registeredOptions</code>, <code>registeredArguments</code>, and <code>registeredParameterGroups</code> methods on <code>CliktCommand</code>.</li> <li>Ability to read default option values from configuration files and other sources. Support for Java property files is built in on JVM, see the <code>json</code> sample for an example of reading from other formats.</li> <li><code>allowMultipleSubcommands</code> parameter to <code>CliktCommand</code> that allows you to pass multiple subcommands in the same call. (docs)</li> <li>Errors from typos in subcommand names will now include suggested corrections. Corrections for options and subcommands are now based on a Jaro-Winkler similarity metric, and can be customized with <code>Context.correctionSuggestor</code></li> </ul>"},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>Update Kotlin to 1.3.70</li> <li><code>convert</code> can be called more than once on the same option or argument, including after calls to conversion functions like <code>int</code> and <code>file</code>.</li> <li><code>CliktCommand.toString</code> now includes the class name</li> <li>Reverted automatic <code>~</code> expansion in <code>file()</code> and <code>path()</code> introduced in 2.5.0. If you need this behavior, you can implement it with code like <code>convert { /* expand tidle */ }.file()</code> </li> </ul>"},{"location":"changelog/#deprecated_3","title":"Deprecated","text":"<ul> <li><code>wrapValue</code> is now deprecated, since <code>convert</code> can be used in its place instead.</li> </ul>"},{"location":"changelog/#250","title":"2.5.0","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Clikt is now available as a Kotlin Multiplatform Project, supporting JVM, NodeJS, and native Windows, Linux, and macOS.</li> <li><code>eagerOption {}</code> function to more easily register eager options.</li> <li>Eager options can now be added to option groups in help out by passing a value for <code>groupName</code> when creating them. </li> <li><code>canBeSymlink</code> parameter to <code>file()</code> and <code>path()</code> conversions that can be used to disallow symlinks</li> <li><code>CliktCommand.eagerOption</code> to simplify creating custom eager options</li> </ul>"},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>The parameter names of <code>file()</code> and <code>path()</code> conversions have changed. The existing names are deprecated, and can be converted to the new usages with an IntelliJ inspection. Note that if you are calling these functions with unnamed arguments (e.g. <code>file(true, false)</code>), you\u2019ll need to add argument names in order to remove the deprecation warning.</li> </ul>"},{"location":"changelog/#deprecated_4","title":"Deprecated","text":"<ul> <li>The <code>CliktCommand.context</code> property has been deprecated in favor of the new name, <code>currentContext</code>, to avoid confusion with the <code>CliktCommand.context{}</code> method.</li> <li><code>NoRunCliktCommand</code> was renamed to <code>NoOpCliktCommand</code>. The existing class is deprecated. (#130)</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li><code>file()</code> and <code>path()</code> conversions will now properly expand leading <code>~</code> in paths to the home directory for <code>mustExist</code>, <code>canBeFile</code>, and <code>canBeDir</code> checks. The property value is unchanged, and can still begin with a <code>~</code>. (#131)</li> </ul>"},{"location":"changelog/#240","title":"2.4.0","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li><code>CompletionCandidates.Fixed</code> now has a secondary convenience constructor that take a <code>vararg</code> of <code>String</code>s</li> <li><code>CompletionCadidates.Custom</code>, which allows you to call other binaries or write a script to generate completions. This class is currently experimental. (#79)</li> <li><code>Option.wrapValue</code> and <code>Argument.wrapValue</code> to make it easier to reuse existing conversion functions.</li> <li><code>ignoreCase</code> parameter to <code>choice()</code> and <code>enum()</code> conversion functions.</li> </ul>"},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li><code>option()</code> and <code>argument()</code> now take optional <code>completionCandidates</code> parameters to override how completion is generated. The constructor and <code>copy</code> functions of <code>OptionsWithValues</code> and <code>ProcessedArgument</code> have changed to support default values.</li> <li>The overloads of <code>findObject</code> (1 2) that take a default value have been renamed <code>findOrSetObject</code>. The existing names are marked with <code>@Deprecated</code>, and IntelliJ can convert your callsites automatically. (#110)</li> <li><code>enum()</code> parameters now accept case-insensitive values by default. You change this behavior by passing <code>ignoreCase = false</code> to <code>enum()</code> (#115)</li> </ul>"},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li><code>groupChoice</code> help output now includes the choices in the help output metavar</li> <li><code>TermUi.edit*</code> functions could freeze on certain editors (#99, thanks @iampravikant and @sebokopter)</li> <li>Shell completion can now handle command names with dashes. (#104)</li> <li>Arguments with <code>=</code> in them could be incorrectly interpreted as options (#106)</li> </ul>"},{"location":"changelog/#230","title":"2.3.0","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li><code>option().groupSwitch()</code>, which works like <code>groupChoice()</code>, but uses a <code>switch()</code> option rather than a <code>choice()</code> option.</li> <li><code>UsageError</code> now has a <code>statusCode</code> parameter (which defaults to 1). If you\u2019re using <code>ClicktCommand.main</code>, the value of <code>statusCode</code> will be passed to <code>exitProcess</code>. </li> </ul>"},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li>Shell completion code is now printed by throwing a <code>PrintCompletionMessage</code> (a subclass of <code>PrintMessage</code>) rather than calling <code>echo</code> directly.</li> </ul>"},{"location":"changelog/#220","title":"2.2.0","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>Added <code>enum()</code> conversion for options and arguments. (#84)</li> </ul>"},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li>There are now several ways of preventing @-file expansion</li> </ul>"},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>Help output missing items when no help text is specified. (#85)</li> <li>Help output not grouping options in groups passed to <code>groupChoice</code>. (#88)</li> </ul>"},{"location":"changelog/#210","title":"2.1.0","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>Ability to prevent rewrapping individual paragraphs in help output.</li> <li>Added parameter <code>required</code> to <code>Option.multiple()</code> to require at least one instance of the option on the command line.</li> </ul>"},{"location":"changelog/#changed_17","title":"Changed","text":"<ul> <li><code>CliktCommand.toString()</code> now includes the names and values of all parameters and subcommands.</li> </ul>"},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li>Create subcommand context when <code>helpOptionNames</code> is empty. (#64)</li> </ul>"},{"location":"changelog/#200","title":"2.0.0","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>Bash autocomplete script generation. A property named <code>completionCandidates</code> has been added to <code>Argument</code> and <code>Option</code> interfaces, and corresponding parameters have been added to the various implementation constructors, as well as the <code>convert</code> functions. You can use this to control the values autocomplete that will be suggested.</li> <li><code>option().split()</code>, and the corresponding <code>OptionWithValues.valueSplit</code>.</li> <li>Marking options as deprecated with <code>option().deprecated()</code></li> <li>You can manually set the pattern to split envvars on by passing a pattern to the <code>envvarSplit</code> parameter of <code>option()</code></li> <li>Option groups, mutually exclusive groups, co-occurring groups, and choice options with groups</li> <li>Support for Command line argument files a.k.a \u201c@-files\u201d</li> </ul>"},{"location":"changelog/#changed_18","title":"Changed","text":"<ul> <li>If multiple <code>--</code> tokens are present on the command line, all subsequent occurrences after the first are now parsed as positional arguments. Previously, subsequent <code>--</code> tokens were skipped.  </li> <li>The <code>PlaintextHelpFormatter</code> has been replaced with <code>CliktHelpFormatter</code>, which is more customizable. See the docs for more info, or the new sample for an example of customizing help output to use ANSI colors.</li> <li>Some of the properties and constructor parameters for <code>OptionWithValues</code> and <code>ProcessedArgument</code> have changed.</li> <li>The <code>OptionDelegate</code> interface has changed, and <code>GroupableOption</code> and <code>ParameterHolder</code> interfaces have been added to work with option groups.</li> <li>Parameter validation now occurs after all parameter delegates have set their values, so the lambdas passed to <code>validate</code> may reference other parameters. </li> </ul>"},{"location":"changelog/#170","title":"1.7.0","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li><code>printHelpOnEmptyArgs</code> parameter to <code>CliktCommand</code> constructor. (#41)</li> </ul>"},{"location":"changelog/#fixed_16","title":"Fixed","text":"<ul> <li>Usage errors now correctly print subcommand names. (#47)</li> <li>Arguments with <code>multiple(required=true)</code> now report an error if no argument is given on the command line. (#36)</li> </ul>"},{"location":"changelog/#160","title":"1.6.0","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li><code>.multiple().unique()</code> modifier for options and arguments.</li> </ul>"},{"location":"changelog/#fixed_17","title":"Fixed","text":"<ul> <li>Support multi-line input when redirecting stdin</li> </ul>"},{"location":"changelog/#150","title":"1.5.0","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>Ability to use alternate output streams rather than stdin and stdout by setting <code>Context.console</code> or by passing a console to <code>TermUI</code> functions.</li> </ul>"},{"location":"changelog/#140","title":"1.4.0","text":""},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li><code>path()</code> type for parameter values</li> </ul>"},{"location":"changelog/#changed_19","title":"Changed","text":"<ul> <li>Clikt now targets JVM 8 bytecode</li> <li>Responses to <code>TermUi.confirm()</code> are now case-insensitive</li> </ul>"},{"location":"changelog/#130","title":"1.3.0","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li><code>defaultLazy</code> extension for options and arguments</li> </ul>"},{"location":"changelog/#changed_20","title":"Changed","text":"<ul> <li><code>main</code> now prints messages to stderr instead of stdout</li> </ul>"},{"location":"changelog/#fixed_18","title":"Fixed","text":"<ul> <li>Parameter help messages are now wrapped more consistently</li> </ul>"},{"location":"changelog/#120","title":"1.2.0","text":""},{"location":"changelog/#added_20","title":"Added","text":"<ul> <li>Default parameter to <code>option().default()</code></li> </ul>"},{"location":"changelog/#changed_21","title":"Changed","text":"<ul> <li>Treat tokens with unknown prefixes as arguments (this makes it easier   to pass in file paths without using <code>--</code>).</li> </ul>"},{"location":"changelog/#110","title":"1.1.0","text":""},{"location":"changelog/#added_21","title":"Added","text":"<ul> <li><code>List&lt;String&gt;</code> overloads to <code>CliktCommand.parse</code> and <code>main</code></li> <li><code>err</code> parameter to <code>TermUi.echo</code></li> <li><code>error</code> property to <code>Abort</code></li> </ul>"},{"location":"commands/","title":"Commands","text":"<p>Clikt supports arbitrarily nested commands. You can add one command as a child of another with the <code>subcommands</code> function, which can be called either in an <code>init</code> block, or on an existing instance.</p>"},{"location":"commands/#executing-nested-commands","title":"Executing Nested Commands","text":"<p>For commands with no children, <code>run</code> is called whenever the command line is parsed (unless parsing is aborted from an error or an option like <code>--help</code>).</p> <p>If a command has children, this isn\u2019t the case. Instead, its <code>run</code> is called only if a child command is invoked, just before the subcommand\u2019s <code>run</code>. If a parent command is called without specifying a subcommand, the help page is printed and <code>run</code> is not called.</p> ExampleUsage 1Usage 2 <pre><code>class Tool : CliktCommand() {\nval verbose by option().flag(\"--no-verbose\")\noverride fun run() {\necho(\"Verbose mode is ${if (verbose) \"on\" else \"off\"}\")\n}\n}\n\nclass Execute : CliktCommand() {\noverride fun run() {\necho(\"executing\")\n}\n}\n\nfun main(args: Array&lt;String&gt;) = Tool().subcommands(Execute()).main(args)\n</code></pre> <pre><code>$ ./tool\nUsage: tool [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --verbose / --no-verbose\n  -h, --help                Show this message and exit\n\nCommands:\n  execute\n</code></pre> <pre><code>$ ./tool --verbose execute\nVerbose mode is on\nexecuting\n</code></pre>"},{"location":"commands/#customizing-command-name","title":"Customizing Command Name","text":"<p>The default name for subcommands is inferred as a lowercase name from the command class name. You can also set a name manually in the <code>CliktCommand</code> constructor.</p> ExampleUsage 1Usage 2 <pre><code>class Tool : CliktCommand() {\noverride fun run()= Unit\n}\n\nclass Execute : CliktCommand(name = \"RUN-ME\") {\noverride fun run() {\necho(\"executing\")\n}\n}\n\nfun main(args: Array&lt;String&gt;) = Tool().subcommands(Execute()).main(args)\n</code></pre> <pre><code>$ ./tool RUN-ME\nexecuting\n</code></pre> <pre><code>$ ./tool -h\nUsage: tool [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  -h, --help  Show this message and exit\n\nCommands:\n  RUN-ME\n</code></pre>"},{"location":"commands/#passing-parameters","title":"Passing Parameters","text":"<p>When calling subcommands, the position of options and arguments on the command line affect which command will parse them. A parameter is parsed by a command if it occurs after the command name, but before any other command names.</p> ExampleUsage <pre><code>class Tool : CliktCommand(help = \"A tool that runs\") {\nval verbose by option().flag(\"--no-verbose\")\noverride fun run() = Unit\n}\n\nclass Execute : CliktCommand(help = \"Execute the command\") {\nval name by option()\noverride fun run() = Unit\n}\n\nfun main(args: Array&lt;String&gt;) = Tool().subcommands(Execute()).main(args)\n</code></pre> <pre><code>$ ./tool --help\nUsage: tool [OPTIONS] COMMAND [ARGS]...\n\n  A tool that runs\n\nOptions:\n  --verbose / --no-verbose\n  -h, --help                Show this message and exit\n\nCommands:\n  execute  Execute the command\n</code></pre> <p>If you instead execute <code>--help</code> after the subcommand, the subcommand\u2019s help is printed:</p> <pre><code>$ ./tool execute --help\nUsage: execute [OPTIONS]\n\n  Execute the command\n\nOptions:\n  --name TEXT\n  -h, --help   Show this message and exit\n</code></pre> <p>But executing <code>./tool --help execute</code>, with the option before the subcommand, will cause the parent\u2019s help option to be invoked, printing out <code>Tool</code>\u2018s help page as if you just typed <code>./tool --help</code>.</p>"},{"location":"commands/#nested-handling-and-contexts","title":"Nested Handling And Contexts","text":"<p>Normally nested command are independent of each other: a child can\u2019t access its parent\u2019s parameters. This makes composing commands much easier, but what if you want to pass information to a child command? You can do so with the command\u2019s <code>Context</code>.</p> <p>Every time the command line is parsed, each command creates a new context object for itself that is linked to its parent\u2019s context. <code>Context</code> objects have a number of properties that can be used to customize command line parsing. Although each command creates its own context, the configuration is inherited from the parent context.</p> <p><code>Context</code> objects also have an <code>obj</code> property that can hold an object that can be accessed from child commands.</p> ExampleUsage <pre><code>class Tool : CliktCommand() {\nval verbose by option().flag(\"--no-verbose\")\nval config by findOrSetObject { mutableMapOf&lt;String, String&gt;() }\noverride fun run() {\nconfig[\"VERBOSE\"] = if (verbose) \"on\" else \"off\"\n}\n}\n\nclass Execute : CliktCommand() {\nval config by requireObject&lt;Map&lt;String, String&gt;&gt;()\noverride fun run() {\necho(\"Verbose mode is ${config[\"VERBOSE\"]}\")\n}\n}\n\nfun main(args: Array&lt;String&gt;) = Tool().subcommands(Execute()).main(args)\n</code></pre> <pre><code>$ ./tool --verbose execute\nVerbose mode is on\n</code></pre> <p>The <code>findObject</code>, <code>findOrSetObject</code>, and <code>requireObject</code> functions will walk up the context tree until they find a <code>obj</code> with the given type. If no such object exists, they will either return <code>null</code>, throw an exception, or create an instance of the object and store it on the command\u2019s context, depending on which function you use. Since each context only has a single <code>obj</code>, if you need to store multiple objects on a single context, you could create a data class with everything you want to store and set that as your <code>obj</code>.</p> <p>Note that the <code>findOrSetObject</code> property is lazy and won\u2019t set the Context\u2019s <code>obj</code> until its value is accessed. If you need to set an object for subcommands without accessing the property, you should use <code>currentContext.findOrSetObject</code>, or set <code>currentContext.obj</code> directly, instead.</p> Eager initialization with findOrSetObjectEager initialization with currentContext.obj <pre><code>class Tool : CliktCommand() {\noverride fun run() {\n// runs eagerly\ncurrentContext.findOrSetObject { MyConfig() }\n}\n}\n</code></pre> <pre><code>class Tool : CliktCommand() {\noverride fun run() {\n// runs eagerly, won't look for parent contexts\ncurrentContext.obj = MyConfig()\n}\n}\n</code></pre>"},{"location":"commands/#running-parent-command-without-children","title":"Running Parent Command Without Children","text":"<p>Normally, if a command has children, <code>run</code> is not called unless a child command is invoked on the command line. Instead, <code>--help</code> is called on the parent. If you want to change this behavior to always call <code>run()</code> on the parent, you can do so by setting <code>invokeWithoutSubcommand</code> to <code>true</code>. The <code>Context</code> will then have information on the subcommand that is about to be invoked, if there is one.</p> ExampleUsage 1Usage 2 <pre><code>class Tool : CliktCommand(invokeWithoutSubcommand = true) {\noverride fun run() {\nval subcommand = currentContext.invokedSubcommand\nif (subcommand == null) {\necho(\"invoked without a subcommand\")\n} else {\necho(\"about to run ${subcommand.commandName}\")\n}\n}\n}\n\nclass Execute : CliktCommand() {\noverride fun run() {\necho(\"running subcommand\")\n}\n}\n\nfun main(args: Array&lt;String&gt;) = Tool().subcommands(Execute()).main(args)\n</code></pre> <pre><code>$ ./tool\ninvoked without a subcommand\n</code></pre> <pre><code>$./tool execute\nabout to run execute\nrunning subcommand\n</code></pre>"},{"location":"commands/#customizing-contexts","title":"Customizing Contexts","text":"<p>Contexts have a number of properties that can be customized, and which are inherited by child commands. You can change these properties with the <code>context</code> builder function, which can be called in an <code>init</code> block, or on a command instance.</p> <p>For example, you can change the name of help option. These definitions are equivalent:</p> Version 1Version 2Usage <pre><code>class Cli : NoOpCliktCommand() {\ninit {\ncontext { helpOptionNames = setOf(\"/help\") }\n}\n}\nfun main(args: Array&lt;String&gt;) = Cli()\n</code></pre> <pre><code>class Cli : NoOpCliktCommand()\nfun main(args: Array&lt;String&gt;) = Cli()\n.context { helpOptionNames = setOf(\"/help\") }\n.main(args)\n</code></pre> <pre><code>$ ./cli --help\nUsage: cli [OPTIONS]\n\nOptions:\n  -h, --help  print the help\n</code></pre>"},{"location":"commands/#printing-the-help-message-when-no-arguments-are-given","title":"Printing the Help Message When No Arguments Are Given","text":"<p>Normally, if a command is called with no values on the command line, a usage error is printed if there are required parameters, or <code>run</code> is called if there aren\u2019t any.</p> <p>You can change this behavior by passing <code>printHelpOnEmptyArgs = true</code> to your command\u2019s constructor. This will cause a help message to be printed when no values are provided on the command line, regardless of the parameters in your command.</p> ExampleUsage <pre><code>class Cli : CliktCommand(printHelpOnEmptyArgs = true) {\nval arg by argument()\noverride fun run() { echo(\"Command ran\") }\n}\n</code></pre> <pre><code>$ ./cli\nUsage: cli [OPTIONS]\n\nOptions:\n  -h, --help  print the help\n</code></pre>"},{"location":"commands/#warnings-and-other-messages","title":"Warnings and Other Messages","text":"<p>When you want to show information to the user, you\u2019ll usually want to use the functions for printing to stdout directly.</p> <p>However, there\u2019s another mechanism that can be useful when writing reusable parameter code: command messages. These messages are buffered during parsing and printed all at once immediately before a command\u2019s <code>run</code> is called. They are not printed if there are any errors in parsing. This type of message is used by Clikt for <code>deprecating options</code>.</p> <p>You can issue a command message by calling <code>CliktCommand.issueMessage</code> or with the <code>message</code> function available in the context of parameter transformers.</p> ExampleUsage 1Usage 2 <pre><code>class Cli : CliktCommand() {\n// This will print the warning when the option is given, but not if there are errors\nval opt by option().validate {\nif (it.isEmpty()) message(\"Empty strings are not recommended\")\n}\noverride fun run() {\necho(\"command run\")\n}\n}\n</code></pre> <pre><code>$ ./cli --opt=''\nEmpty strings are not recommended\ncommand run\n</code></pre> <pre><code>$ ./cli --opt='' --oops\nError: no such option: \"--oops\".\n</code></pre> <p>You can disable automatic message printing on the command\u2019s context:</p> ExampleUsage <pre><code>class Cli : CliktCommand() {\ninit { context { printExtraMessages = false } }\nval opt by option().validate {\nif (it.isEmpty()) message(\"Empty strings are not recommended\")\n}\noverride fun run() {\necho(\"command run\")\n}\n}\n</code></pre> <pre><code>$ ./cli --opt=''\ncommand run\n</code></pre>"},{"location":"commands/#chaining-and-repeating-subcommands","title":"Chaining and Repeating Subcommands","text":"<p>Some command line interfaces allow you to call more than one subcommand at a time. For example, you might do something like <code>gradle clean build publish</code> to run the <code>clean</code> task, then the <code>build</code> task, then the <code>publish</code> task, which are all subcommands of <code>gradle</code>.</p> <p>To do this with Clikt, pass <code>allowMultipleSubcommands = true</code> to your CliktCommand constructor.</p> ExampleUsage <pre><code>class Compiler: CliktCommand(allowMultipleSubcommands = true) {\noverride fun run() {\necho(\"Running compiler\")\n}\n}\n\nclass Clean: CliktCommand() {\nval force by option().flag()\noverride fun run() {\necho(\"Cleaning (force=$force)\")\n}\n}\n\nclass Build: CliktCommand() {\nval file by argument().file()\noverride fun run() {\necho(\"Building $file\")\n}\n}\n\nfun main(args: Array&lt;String&gt;) = Compiler().subcommands(Clean(), Build()).main(args)\n</code></pre> <pre><code>$ ./compiler clean --force build main.kt\nRunning compiler\nCleaning (force=true)\nBuilding main.kt\n</code></pre> <p>The parent command will <code>run</code> once, and each subcommand will <code>run</code> once each time they\u2019re called.</p>"},{"location":"commands/#parsing-multiple-subcommands","title":"Parsing multiple subcommands","text":"<p>Note that enabling <code>allowMultipleSubcommands</code> will disable <code>allowInterspersedArgs</code> on the command and all its subcommands. If both were allowed to be enabled at the same time, then not all command lines could be parsed unambiguously.</p> <p>When parsing in this mode, tokens are consumed greedily by a subcommand until it encounters an argument token it doesn\u2019t support, at which point the parent command resumes parsing where the subcommand left off. This means that if you have a subcommand with an <code>argument().multiple()</code> parameter, you won\u2019t be able to call any other subcommands after that one, since it will consume the rest of the command line.</p> <p>Subcommands of a command with <code>allowMultipleSubcommands=true</code> can themselves have subcommands, but cannot have <code>allowMultipleSubcommands=true</code>.</p>"},{"location":"documenting/","title":"Documenting Scripts","text":"<p>Clikt takes care of creating formatted help messages for commands. There are a number of ways to customize the default behavior. You can also implement your own <code>HelpFormatter</code> and set it on the command\u2019s context.</p>"},{"location":"documenting/#help-texts","title":"Help Texts","text":"<p>Commands and parameters accept a <code>help</code> argument. Commands also accept an <code>epilog</code> argument, which is printed after the parameters and commands on the help page. All text is automatically trimmed of leading indentation and re-wrapped to the terminal width.</p> <p>As an alternative to passing your help strings as function arguments, you can also use the <code>help()</code> extensions for your options, and override <code>commandHelp</code> and <code>commandHelpEpilog</code> on your commands.</p> ExampleAlternate styleHelp output <pre><code>class Hello : CliktCommand(help = \"\"\"\n    This script prints NAME COUNT times.\n\n    COUNT must be a positive number, and defaults to 1.\n    \"\"\"\n) {\nval count by option(\"-c\", \"--count\", metavar=\"COUNT\", help = \"number of greetings\").int().default(1)\nval name by argument()\noverride fun run() = repeat(count) { echo(\"Hello $name!\") }\n}\n</code></pre> <pre><code>class Hello : CliktCommand() {\noverride val commandHelp = \"\"\"\n        This script prints NAME COUNT times.\n\n        COUNT must be a positive number, and defaults to 1.\n    \"\"\"\nval count by option(\"-c\", \"--count\", metavar=\"COUNT\").int().default(1)\n.help(\"number of greetings\")\nval name by argument()\noverride fun run() = repeat(count) { echo(\"Hello $name!\") }\n}\n</code></pre> <pre><code>$ ./hello --help\nUsage: hello [OPTIONS] NAME\n\n  This script prints NAME COUNT times.\n\n  COUNT must be a positive number, and defaults to 1.\n\nOptions:\n  -c, --count COUNT number of greetings\n  -h, --help        Show this message and exit\n</code></pre> <p>Option names and metavars will appear in help output even if no help string is specified for them. On the other hand, arguments only appear in the usage string. It is possible to add a help string to arguments which will be added to the help page, but the Unix convention is to just describe arguments in the command help.</p>"},{"location":"documenting/#preformatting-paragraphs","title":"Preformatting Paragraphs","text":"<p>By default, Clikt will rewrap all paragraphs in your text to the terminal width. This can be undesirable if you have some preformatted text, such as source code or a bulleted list.</p> <p>You can preformat a paragraph by surrounding it with markdown-style triple backticks. The backticks will be removed from the output, and if the backticks are on a line by themselves, the line will be removed. All whitespace and newlines in the paragraph will be preserved, and will be be rewrapped.</p> ExampleHelp output <pre><code>class Tool : NoOpCliktCommand(help = \"\"\"This is my command.\n\n      This paragraph will be wrapped, but the following list will not:\n\n      ```\n      - This is a list\n      - Its newlines will remain intact\n      ```\n\n      This is a new paragraph that will be wrapped if it's wider than the teminal width.\n      \"\"\")\n</code></pre> <pre><code>Usage: tool\n\n  This is my command.\n\n  This paragraph will be wrapped, but the following list\n  will not:\n\n  - This is a list\n  - It's newlines will remain intact\n\n  This is a new paragraph that will be wrapped if it's wider\n  than the terminal width.\n\nOptions:\n  -h, --help  Show this message and exit\n</code></pre>"},{"location":"documenting/#manual-line-breaks","title":"Manual Line Breaks","text":"<p>If you want to insert a line break manually without preformmating the entire paragraph, you can use the Unicode Next Line (NEL) character. You can type a NEL with the unicode literal <code>\\u0085</code>.</p> <p>Clikt will treat NEL similarly to how <code>&lt;br&gt;</code> behaves in HTML: The NEL will be replaced with a line break in the output, and the paragraph will still be wrapped to the terminal width.</p> ExampleHelp output <pre><code>class Tool : NoOpCliktCommand() {\nval option by option(\nhelp=\"This help will be at least two lines.\\u0085(this will start a new line)\"\n)\n}\n</code></pre> <pre><code>Usage: tool\n\nOptions:\n  --option    This help will be at least\n              two lines.\n              (this will start a new\n              line)\n  -h, --help  Show this message and exit\n</code></pre> <p>Tip</p> <p>In raw multiline strings (which do not parse escape sequences), you\u2019ll need to insert the NEL with a string template such as <code>${\"\\u0085\"}</code>.</p>"},{"location":"documenting/#subcommand-short-help","title":"Subcommand Short Help","text":"<p>Subcommands are listed in the help page based on their name. They have a short help string which is the first line of their help.</p> ExampleUsage <pre><code>class Tool : NoOpCliktCommand()\n\nclass Execute : NoOpCliktCommand(help = \"\"\"\n    Execute the command.\n\n    The command will be executed.\n    \"\"\")\n\nclass Abort : NoOpCliktCommand(help=\"Kill any running commands.\")\n</code></pre> <pre><code>$ ./tool --help\nUsage: tool [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  -h, --help  Show this message and exit\n\nCommands:\n  execute  Execute the command.\n  abort    Kill any running commands.\n</code></pre>"},{"location":"documenting/#help-option-customization","title":"Help Option Customization","text":"<p>Clikt handles the help option is specially. It is added automatically to every command. Any help option name that conflicts with another option is not used for the help option. If the help option has no unique names, it is not added.</p> <p>You can change the help option\u2019s name and help message on the command\u2019s context:</p> ExampleUsage <pre><code>class HelpLocalization: Localization {\noverride fun helpOptionMessage(): String = \"show the help\"\n}\n\nclass Tool : NoOpCliktCommand() {\ninit {\ncontext {\nhelpOptionNames = setOf(\"/help\")\nlocalization = HelpLocalization()\n}\n}\n}\n</code></pre> <pre><code>$ ./tool /help\nUsage: tool [OPTIONS]\n\nOptions:\n  /help  show the help\n</code></pre> <p>If you don\u2019t want a help option to be added, you can set <code>helpOptionNames = emptySet()</code></p>"},{"location":"documenting/#default-values-in-help","title":"Default Values in Help","text":"<p>You can configure the help formatter to show default values in the help output by passing <code>showDefaultValues = true</code> to the <code>CliktHelpFormatter</code>. By default, the string value of the default value will be shown. You can show a different value by passing the value you want to show to the <code>defaultForHelp</code> parameter of <code>default</code>.</p> ExampleUsage <pre><code>class Tool : NoOpCliktCommand() {\ninit {\ncontext { helpFormatter = CliktHelpFormatter(showDefaultValues = true) }\n}\n\nval a by option(help = \"this is optional\").default(\"value\")\nval b by option(help = \"this is also optional\").default(\"value\", defaultForHelp=\"chosen for you\")\n}\n</code></pre> <pre><code>$ ./tool --help\nUsage: tool [OPTIONS]\n\nOptions:\n  --a TEXT    this is optional (default: value)\n  --b TEXT    this is also optional (default: chosen for you)\n</code></pre>"},{"location":"documenting/#required-options-in-help","title":"Required Options in Help","text":"<p>By default, <code>required</code> options are displayed the same way as other options. The help formatter includes two different ways to show that an option is required.</p>"},{"location":"documenting/#required-option-marker","title":"Required Option Marker","text":"<p>You can pass a character to the <code>requiredOptionMarker</code> argument of the <code>CliktHelpFormatter</code>.</p> ExampleUsage <pre><code>class Tool : NoOpCliktCommand() {\ninit {\ncontext { helpFormatter = CliktHelpFormatter(requiredOptionMarker = \"*\") }\n}\n\nval option by option(help = \"this is optional\")\nval required by option(help = \"this is required\").required()\n}\n</code></pre> <pre><code>$ ./tool --help\nUsage: tool [OPTIONS]\n\nOptions:\n  --option TEXT    this is optional\n* --required TEXT  this is required\n  -h, --help       Show this message and exit\n</code></pre>"},{"location":"documenting/#required-option-tag","title":"Required Option Tag","text":"<p>You can also show a tag for required options by passing <code>showRequiredTag = true</code> to the <code>CliktHelpFormatter</code>.</p> ExampleUsage <pre><code>class Tool : CliktCommand() {\ninit {\ncontext { helpFormatter = CliktHelpFormatter(showRequiredTag = true) }\n}\n\nval option by option(help = \"this is optional\")\nval required by option(help = \"this is required\").required()\n}\n</code></pre> <pre><code>$ ./tool --help\nUsage: tool [OPTIONS]\n\nOptions:\n  --option TEXT    this is optional\n  --required TEXT  this is required (required)\n  -h, --help       Show this message and exit\n</code></pre>"},{"location":"documenting/#grouping-options-in-help","title":"Grouping Options in Help","text":"<p>You can group options into separate help sections by using OptionGroup and importing groups.provideDelegate. The name of the group will be shown in the output. You can also add an extra help message to be shown with the group. Groups can\u2019t be nested.</p> ExampleUsage <pre><code>import com.github.ajalt.clikt.parameters.groups.provideDelegate\n\nclass UserOptions : OptionGroup(\nname = \"User Options\",\nhelp = \"Options controlling the user\"\n) {\nval name by option(help = \"user name\")\nval age by option(help = \"user age\").int()\n}\n\nclass Tool : NoOpCliktCommand() {\nval userOptions by UserOptions()\n}\n</code></pre> <pre><code>$ ./tool --help\nUsage: cli [OPTIONS]\n\nUser Options:\n\n  Options controlling the user\n\n  --name TEXT  user name\n  --age INT    user age\n\nOptions:\n  -h, --help  Show this message and exit\n</code></pre>"},{"location":"documenting/#suggesting-corrections-for-mistyped-parameters","title":"Suggesting Corrections for Mistyped Parameters","text":"<p>When an option or subcommand is mistyped, Clikt will suggest corrections that are similar to the typed value.</p> Mistyped OptionMistyped Subcommand <pre><code>$ ./cli --sise=5\nError: no such option: \"--sise\". Did you mean \"--size\"?\n</code></pre> <pre><code>$ ./cli building\nUsage: cli [OPTIONS] COMMAND [ARGS]...\n\nError: no such subcommand: \"building\". Did you mean \"build\"?\n</code></pre> <p>By default, Clikt will suggest corrections of any similar option or subcommand name based on a similarity metric. You can customize the suggestions by setting a <code>correctionSuggestor</code> on your command\u2019s context.</p> <pre><code>class Cli : NoOpCliktCommand() {\ninit {\ncontext {\n// Only suggest corrections that start with the entered value\ncorrectionSuggestor = { enteredValue, possibleValues -&gt;\npossibleValues.filter { it.startsWith(enteredValue) }\n}\n}\n}\n}\n</code></pre>"},{"location":"documenting/#localization","title":"Localization","text":"<p>You can localize error messages by implementing <code>Localization</code> and setting the <code>localization</code> property on your context.</p> ExampleUsage <pre><code>class CursiveLocalization : Localization {\noverride fun usageTitle() = \"\ud835\udcb0\ud835\udcc8\ud835\udcb6\ud835\udc54\ud835\udc52:\"\noverride fun optionsTitle() = \"\ud835\udcaa\ud835\udcc5\ud835\udcc9\ud835\udcbe\ud835\udc5c\ud835\udcc3\ud835\udcc8:\"\noverride fun optionsMetavar() = \"[\ud835\udcaa\ud835\udcab\ud835\udcaf\ud835\udc3c\ud835\udcaa\ud835\udca9\ud835\udcae]:\"\noverride fun helpOptionMessage() = \"\ud835\udcae\ud835\udcbd\ud835\udc5c\ud835\udccc \ud835\udcc9\ud835\udcbd\ud835\udcbe\ud835\udcc8 \ud835\udcc2\ud835\udc52\ud835\udcc8\ud835\udcc8\ud835\udcb6\ud835\udc54\ud835\udc52 \ud835\udcb6\ud835\udcc3\ud835\udcb9 \ud835\udc52\ud835\udccd\ud835\udcbe\ud835\udcc9\"\n\n// ... override the rest of the strings here\n}\n\nclass I18NTool : NoOpCliktCommand(help = \"\ud835\udcaf\ud835\udcbd\ud835\udcbe\ud835\udcc8 \ud835\udcc9\ud835\udc5c\ud835\udc5c\ud835\udcc1 \ud835\udcbe\ud835\udcc8 \ud835\udcbe\ud835\udcc3 \ud835\udcb8\ud835\udcca\ud835\udcc7\ud835\udcc8\ud835\udcbe\ud835\udccb\ud835\udc52\") {\ninit {\ncontext { localization = CursiveLocalization() }\n}\n}\n</code></pre> <pre><code>$ ./i18ntool --help\n\ud835\udcb0\ud835\udcc8\ud835\udcb6\ud835\udc54\ud835\udc52: i18ntool [\ud835\udcaa\ud835\udcab\ud835\udcaf\ud835\udc3c\ud835\udcaa\ud835\udca9\ud835\udcae]\n\n  \ud835\udcaf\ud835\udcbd\ud835\udcbe\ud835\udcc8 \ud835\udcc9\ud835\udc5c\ud835\udc5c\ud835\udcc1 \ud835\udcbe\ud835\udcc8 \ud835\udcbe\ud835\udcc3 \ud835\udcb8\ud835\udcca\ud835\udcc7\ud835\udcc8\ud835\udcbe\ud835\udccb\ud835\udc52\n\n\ud835\udcaa\ud835\udcc5\ud835\udcc9\ud835\udcbe\ud835\udc5c\ud835\udcc3\ud835\udcc8:\n  -h, --help  \ud835\udcae\ud835\udcbd\ud835\udc5c\ud835\udccc \ud835\udcc9\ud835\udcbd\ud835\udcbe\ud835\udcc8 \ud835\udcc2\ud835\udc52\ud835\udcc8\ud835\udcc8\ud835\udcb6\ud835\udc54\ud835\udc52 \ud835\udcb6\ud835\udcc3\ud835\udcb9 \ud835\udc52\ud835\udccd\ud835\udcbe\ud835\udcc9\n</code></pre>"},{"location":"exceptions/","title":"Exception Handling","text":"<p>Clikt uses exceptions internally to signal that processing has ended early for any reason. This includes incorrect command line usage, or printing a help page.</p>"},{"location":"exceptions/#where-are-exceptions-handled","title":"Where are Exceptions Handled?","text":"<p>When you call <code>CliktCommand.main</code>, it will parse the command line and catch any <code>CliktError</code> and <code>Abort</code> exceptions. If it catches one, it will then print out the appropriate information and exit the process. If the caught exception is a <code>PrintMessage</code> or <code>PrintHelpMessage</code>, the process exit status will be 0 and the message will be printed to stdout. Otherwise it will exit with status 1 and print the message to stderr.</p> <p>Any other types of exceptions indicate a programming error, and are not caught by <code>main</code>. However, <code>convert</code> and the other parameter transformations will wrap exceptions thrown inside them in a <code>UsageError</code>, so if you define a custom transformation, you don\u2019t have to worry about an exception escaping to the user.</p>"},{"location":"exceptions/#handling-exceptions-manually","title":"Handling Exceptions Manually","text":"<p><code>CliktCommand.main</code> is just a <code>try</code>/<code>catch</code> block surrounding <code>CliktCommand.parse</code>, so if don\u2019t want exceptions to be caught, you can call <code>parse</code> wherever you would normally call <code>main</code>.</p> <pre><code>fun main(args: Array&lt;String&gt;) = Cli().parse(args)\n</code></pre>"},{"location":"exceptions/#which-exceptions-exist","title":"Which Exceptions Exist?","text":"<p>Clikt will throw <code>Abort</code> if it needs to halt execution immediately without a specific message. All other exceptions are subclasses of <code>UsageError</code>.</p> <p>The following subclasses exist:</p> <ul> <li><code>PrintMessage</code> : The exception\u2019s message should be printed.</li> <li><code>PrintHelpMessage</code> : The help page for the exception\u2019s command should be printed.</li> <li><code>PrintCompletionMessage</code> : Shell completion code for the command should be printed.</li> <li><code>UsageError</code> : The command line was incorrect in some way. All other exceptions subclass from this. These exceptions are automatically augmented with extra information about the current parameter, if possible.</li> <li><code>ProgramResult</code> : The program should exit with the <code>statusCode</code> from this exception.</li> <li><code>BadParameterValue</code> : A parameter was given the correct number of values, but of invalid format or type.</li> <li><code>MissingOption</code> and <code>MissingArgument</code>: A required parameter was not provided.</li> <li><code>NoSuchOption</code> : An option was provided that does not exist.</li> <li><code>NoSuchSubcommand</code> : A subcommand was called that does not exist.</li> <li><code>IncorrectOptionValueCount</code> : An option was supplied but the number of values supplied to the option was incorrect.</li> <li><code>IncorrectArgumentValueCount</code> : An argument was supplied but the number of values supplied was incorrect.</li> <li><code>MutuallyExclusiveGroupException</code> : Multiple options in a mutually exclusive group were supplied when the group is restricted to a single value.</li> <li><code>FileNotFound</code> : A required configuration file or @-file was not found.</li> <li><code>InvalidFileFormat</code> : A configuration file or @-file failed to parse correctly.</li> </ul>"},{"location":"migration/","title":"Upgrading to Newer Releases","text":""},{"location":"migration/#upgrading-to-30","title":"Upgrading to 3.0","text":""},{"location":"migration/#maven-coordinates","title":"Maven Coordinates","text":"<p>Clikt\u2019s Maven groupId changed from <code>com.github.ajalt</code> to <code>com.github.ajalt.clikt</code>. So the full coordinate is now <code>com.github.ajalt.clikt:clikt:3.0.0</code>.</p> <p>With the new Multiplatform plugin in Kotlin 1.4, there is no longer a separate <code>clikt-multiplatform</code> artifact. You can use <code>com.github.ajalt.clikt:clikt:3.0.0</code> for both JVM-only and Multiplatform projects.</p>"},{"location":"migration/#environment-variable-splitting","title":"Environment variable splitting","text":"<p>There used to be an <code>envvarSplit</code> parameter to <code>option()</code> and its <code>convert()</code> that would split values coming from an environment variable. This parameter is removed, and values from environment variables are no longer split automatically.</p> <p>If you still want to split option values, you can do so explicitly with <code>split()</code>.</p>"},{"location":"migration/#experimental-apis","title":"Experimental APIs","text":"<p>The Value Source API and Completion Generation APIs no longer require opt-in. You can use these APIs without needing the <code>ExperimentalValueSourceApi</code> or <code>ExperimentalCompletionCandidates</code> annotations.</p>"},{"location":"migration/#localization","title":"Localization","text":"<p>By default, all strings are defined in the <code>Localization</code> object set on your [context][Context.localization.</p> <p>This means that string parameters like <code>usageTitle</code> in the constructor for <code>CliktHelpFormatter</code> have been removed in favor of functions like <code>Localization.usageTitle()</code>.</p> <p><code>Context.helpOptionMessage</code> has also been removed in favor of <code>Localization.helpOptionMessage()</code>. See Help Option Customization for an example.</p>"},{"location":"options/","title":"Options","text":"<p>Options are added to commands by defining a property delegate with the <code>option</code> function.</p>"},{"location":"options/#basic-options","title":"Basic Options","text":"<p>The default option takes one value of type <code>String</code>. The property is nullable. If the option is not given on the command line, the property value will be null. If the option is given at least once, the property will return the value of the last occurrence of the option.</p> ExampleUsage <pre><code>class Hello: CliktCommand() {\nval name by option(help=\"your name\")\noverride fun run() {\necho(\"Hello, $name!\")\n}\n}\n</code></pre> <pre><code>$ ./hello --name=Foo\nHello, Foo!\n</code></pre>"},{"location":"options/#option-names","title":"Option Names","text":"<p>If you don\u2019t specify names for an option, a lowercase hyphen-separated name is automatically inferred from the property. For example, <code>val myOpt by option()</code> will create an option that can be called with <code>--my-opt</code>.</p> <p>You can also specify any number of names for an option manually:</p> <pre><code>class Hello: CliktCommand() {\nval name by option(\"-n\", \"--name\", help=\"your name\")\noverride fun run() {\necho(\"Hello, $name!\")\n}\n}\n</code></pre> <p>Option names that are two characters long (like <code>-n</code>) are treated as POSIX-style short options. You call them with a value like this:</p> Usage 1Usage 2 <pre><code>$ ./hello -nfoo\nHello, foo!\n</code></pre> <pre><code>$ ./hello -n foo\nHello, foo!\n</code></pre> <p>All other option names are considered long options, and can be called like this:</p> Usage 1Usage 2 <pre><code>$ ./hello --name=foo\nHello, foo!\n</code></pre> <pre><code>$ ./hello --name foo\nHello, foo!\n</code></pre>"},{"location":"options/#customizing-options","title":"Customizing Options","text":"<p>The option behavior and delegate type can be customized by calling extension functions on the <code>option</code> call. For example, here are some different option declarations:</p> <pre><code>val a: String? by option()\nval b: Int? by option().int()\nval c: Pair&lt;Int, Int&gt;? by option().int().pair()\nval d: Pair&lt;Int, Int&gt; by option().int().pair().default(0 to 0)\nval e: Pair&lt;Float, Float&gt; by option().float().pair().default(0f to 0f)\n</code></pre> <p>There are three main types of behavior that can be customized independently:</p> <ol> <li>The type of each value in the option.    The value type is <code>String</code> by default, but can be customized with built-in functions like    <code>int</code> or <code>choice</code>, or manually with <code>convert</code>.    This is detailed in the parameters page.</li> <li>The number of values that the option requires.    Options take one value by default, but this can be changed with    built-in functions like <code>pair</code> and <code>triple</code>, or manually with    <code>transformValues</code>.</li> <li>How to handle all calls to the option (i.e. if the option is not present, or is present more than once).    By default, the option delegate value is the null if the option is not given on the command line,    and will use the value of the last occurrence if the option is given more than once. You can    change this behavior with functions like <code>default</code> and <code>multiple</code>.</li> </ol> <p>Since the three types of customizations are orthogonal, you can choose which ones you want to use, and if you implement a new customization, it can be used with all of the existing functions without any repeated code.</p>"},{"location":"options/#default-values","title":"Default Values","text":"<p>By default, option delegates return <code>null</code> if the option wasn\u2019t provided on the command line. You can instead return a default value with <code>default</code>.</p> ExampleUsage 1Usage 2 <pre><code>class Pow : CliktCommand() {\nval exp by option(\"-e\", \"--exp\").double().default(1.0)\noverride fun run() {\necho(\"2 ^ $exp = ${(2.0).pow(exp)}\")\n}\n}\n</code></pre> <pre><code>$ ./pow -e 8\n2 ^ 8.0 = 256.0\n</code></pre> <pre><code>$ ./pow\n2 ^ 1.0 = 2.0\n</code></pre> <p>If the default value is expensive to compute, or you want to use another parameter as the default, you can use <code>defaultLazy</code> instead of <code>default</code>. It has the same effect, but you give it a lambda returning the default value, and the lambda will only be called if the option isn\u2019t present on the command line.</p>"},{"location":"options/#multi-value-options","title":"Multi Value Options","text":"<p>Options can take any fixed number of values separated by whitespace, or a variable number of values separated by a non-whitespace delimiter you specify. If you want a variable number of values separated by whitespace, you need to use an argument instead.</p>"},{"location":"options/#options-with-fixed-number-of-values","title":"Options With Fixed Number of Values","text":"<p>There are built in functions for options that take two values (<code>pair</code>, which uses a <code>Pair</code>), or three values (<code>triple</code>, which uses a <code>Triple</code>). You can change the type of each value as normal with functions like <code>int</code>.</p> <p>If you need more values, you can provide your own container with <code>transformValues</code>. You give that function the number of values you want, and a lambda that will transform a list of values into the output container. The list will always have a size equal to the number you specify. If the user provides a different number of values, Clikt will inform the user and your lambda won\u2019t be called.</p> ExampleUsage <pre><code>data class Quad&lt;out T&gt;(val a: T, val b: T, val c: T, val d: T)\nfun &lt;T&gt; Quad&lt;T&gt;.toList(): List&lt;T&gt; = listOf(a, b, c, d)\n\nclass Geometry : CliktCommand() {\nval square by option().int().pair()\nval cube by option().int().triple()\nval tesseract by option().int().transformValues(4) { Quad(it[0], it[1], it[2], it[3]) }\noverride fun run() {\necho(\"Square has dimensions ${square?.toList()?.joinToString(\"x\")}\")\necho(\"Cube has dimensions ${cube?.toList()?.joinToString(\"x\")}\")\necho(\"Tesseract has dimensions ${tesseract?.toList()?.joinToString(\"x\")}\")\n}\n}\n</code></pre> <pre><code>$ ./geometry --square 1 2 --cube 3 4 5 --tesseract 6 7 8 9\nSquare has dimensions 1x2\nCube has dimensions 3x4x5\nTesseract has dimensions 6x7x8x9\n</code></pre>"},{"location":"options/#options-with-a-variable-number-of-values","title":"Options With a Variable Number of Values","text":"<p>You can use <code>split</code> to allow a variable number of values to a single option invocation by separating the values with non-whitespace delimiters. This will also split values from environment variables.</p> ExampleUsageUsage with Environment Variable <pre><code>class C : CliktCommand() {\nval profiles by option(\"-P\", envvar=\"PROFILES\").split(\",\")\noverride fun run() {\nfor (profile in profiles) {\necho(profile)\n}\n}\n}\n</code></pre> <pre><code>$ ./split -P profile-1,profile-2\nprofile-1\nprofile-2\n</code></pre> <pre><code>$ export PROFILES=profile-1,profile-2\n$ ./split\nprofile-1\nprofile-2\n</code></pre>"},{"location":"options/#multiple-options","title":"Multiple Options","text":"<p>Normally, when an option is provided on the command line more than once, only the values from the last occurrence are used. But sometimes you want to keep all values provided. For example, <code>git commit -m foo -m bar</code> would create a commit message with two lines: <code>foo</code> and <code>bar</code>. To get this behavior with Clikt, you can use <code>multiple</code>. This will cause the property delegate value to be a list, where each item in the list is the value of from one occurrence of the option. If the option is never given, the list will be empty (or you can specify a default to use).</p> ExampleUsage <pre><code>class Commit : CliktCommand() {\nval message: List&lt;String&gt; by option(\"-m\").multiple()\noverride fun run() {\necho(message.joinToString(\"\\n\"))\n}\n}\n</code></pre> <pre><code>$ ./commit -m foo -m bar\nfoo\nbar\n</code></pre> <p>You can combine <code>multiple</code> with item type conversions and multiple values.</p> <pre><code>val opt: List&lt;Pair&lt;Int, Int&gt;&gt; by option().int().pair().multiple()\n</code></pre>"},{"location":"options/#default-values-for-optionmultiple","title":"Default values for option().multiple()","text":"<p>You can also supply a default value to <code>multiple</code> or require at least one value be present on the command line. These are specified as arguments rather than with separate extension functions since they don\u2019t change the type of the delegate.</p> RequiredDefault <pre><code>val opt: List&lt;String&gt; by option().multiple(required=true)\n</code></pre> <pre><code>val opt: List&lt;String&gt; by option().multiple(default=listOf(\"default message\"))\n</code></pre>"},{"location":"options/#deduplicating-optionmultiple-into-a-unique-set","title":"Deduplicating option().multiple() into a unique set","text":"<p>You can discard duplicate values from a <code>multiple</code> option with <code>unique</code>.</p> ExampleUsage <pre><code>class Build : CliktCommand() {\nval platforms: Set&lt;String&gt; by option(\"-p\").multiple().unique()\noverride fun run() {\necho(\"Building for platforms: $platforms\")\n}\n}\n</code></pre> <pre><code>$ ./build -p android -p ios -p android\nBuilding for platforms: [android, ios]\n</code></pre>"},{"location":"options/#key-value-and-map-options","title":"Key-Value and Map Options","text":"<p>You can split an option\u2019s value into a key-value pair with <code>splitPair</code>. By default, the delimiter <code>=</code> will be used to split. You can also use <code>associate</code> to allow the option to be specified multiple times, and have its values collected in a map.</p> ExampleUsage <pre><code>class Build : CliktCommand() {\nval systemProp: Map&lt;String, String&gt; by option(\"-D\", \"--system-prop\").associate()\n\noverride fun run() {\necho(systemProp)\n}\n}\n</code></pre> <pre><code>$ ./build -Dplace=here --system-prop size=small\n{place=here, size=small}\n</code></pre>"},{"location":"options/#boolean-flag-options","title":"Boolean Flag Options","text":"<p>Flags are options that don\u2019t take a value. Boolean flags can be enabled or disabled, depending on the name used to invoke the option. You can turn an option into a boolean flag with <code>flag</code>. That function takes an optional list of secondary names that will be added to any existing or inferred names for the option. If the option is invoked with one of the secondary names, the delegate will return false. It\u2019s a good idea to always set secondary names so that a user can disable the flag if it was enabled previously.</p> ExampleUsage 1Usage 2 <pre><code>class Cli : CliktCommand() {\nval flag by option(\"--on\", \"-o\").flag(\"--off\", \"-O\", default = false)\noverride fun run() {\necho(flag)\n}\n}\n</code></pre> <pre><code>$ ./cli -o\ntrue\n</code></pre> <pre><code>$ ./cli --on --off\nfalse\n</code></pre> <p>Multiple short flag options can be combined when called on the command line:</p> ExampleUsage <pre><code>class Cli : CliktCommand() {\nval flagA by option(\"-a\").flag()\nval flagB by option(\"-b\").flag()\nval foo by option(\"-f\")\noverride fun run() {\necho(\"$flagA $flagB $foo\")\n}\n}\n</code></pre> <pre><code>$ ./cli -abfFoo\ntrue true Foo\n</code></pre>"},{"location":"options/#counted-flag-options","title":"Counted Flag Options","text":"<p>You might want a flag option that counts the number of times it occurs on the command line. You can use <code>counted</code> for this.</p> ExampleUsage <pre><code>class Log : CliktCommand() {\nval verbosity by option(\"-v\").counted()\noverride fun run() {\necho(\"Verbosity level: $verbosity\")\n}\n}\n</code></pre> <pre><code>$ ./log -vvv\nVerbosity level: 3\n</code></pre>"},{"location":"options/#feature-switch-flags","title":"Feature Switch Flags","text":"<p>Another way to use flags is to assign a value to each option name. You can do this with <code>switch</code>, which takes a map of option names to values. Note that the names in the map replace any previously specified or inferred names.</p> ExampleUsage <pre><code>class Size : CliktCommand() {\nval size by option().switch(\n\"--large\" to \"large\",\n\"--small\" to \"small\"\n).default(\"unknown\")\noverride fun run() {\necho(\"You picked size $size\")\n}\n}\n</code></pre> <pre><code>$ ./size --small\nYou picked size small\n</code></pre>"},{"location":"options/#choice-options","title":"Choice Options","text":"<p>You can restrict the values that a regular option can take to a set of values using <code>choice</code>. You can also map the input values to new types.</p> ExampleUsage 1Usage 2Usage 3 <pre><code>class Digest : CliktCommand() {\nval hash by option().choice(\"md5\", \"sha1\")\noverride fun run() {\necho(hash)\n}\n}\n</code></pre> <pre><code>$ ./digest --hash=md5\nmd5\n</code></pre> <pre><code>$ ./digest --hash=sha256\nUsage: digest [OPTIONS]\n\nError: Invalid value for \"--hash\": invalid choice: sha256. (choose from md5, sha1)\n</code></pre> <pre><code>$ ./digest --help\nUsage: digest [OPTIONS]\n\nOptions:\n  --hash [md5|sha1]\n  -h, --help         Show this message and exit\n</code></pre>"},{"location":"options/#mutually-exclusive-option-groups","title":"Mutually Exclusive Option Groups","text":"<p>If <code>choice</code> or <code>switch</code> options aren\u2019t flexible enough, you can use <code>mutuallyExclusiveOptions</code> to group any nullable options into a mutually exclusive group. If more than one of the options in the group is given on the command line, the last value is used.</p> <p>If you want different types for each option, you can wrap them in a sealed class.</p> ExampleUsage 1Usage 2Usage 3 <pre><code>sealed class Fruit {\ndata class Oranges(val size: String): Fruit()\ndata class Apples(val count: Int): Fruit()\n}\nclass Order : CliktCommand() {\nval fruit: Fruit? by mutuallyExclusiveOptions&lt;Fruit&gt;(\noption(\"--oranges\").convert { Oranges(it) },\noption(\"--apples\").int().convert { Apples(it) }\n)\n\noverride fun run() = echo(fruit)\n}\n</code></pre> <pre><code>$ ./order --apples=10\nApples(count=10)\n</code></pre> <pre><code>$ ./order --oranges=small\nOranges(size=small)\n</code></pre> <pre><code>$ ./order --apples=10 --oranges=large\nOranges(size=large)\n</code></pre> <p>You can enforce that only one of the options is given with <code>single</code>:</p> ExampleUsage <pre><code>val fruit: Fruit? by mutuallyExclusiveOptions&lt;Fruit&gt;(\noption(\"--apples\").convert { Apples(it.toInt()) },\noption(\"--oranges\").convert { Oranges(it) }\n).single()\n</code></pre> <pre><code>$ ./order --apples=10 --oranges=small\nUsage: order [OPTIONS]\n\nError: option --apples cannot be used with --oranges\n</code></pre> <p>Like regular options, you can make the entire group <code>required</code>, or give it a <code>default</code> value.</p> <p>Like other option groups, you can specify a <code>name</code> and <code>help</code> text for the group if you want to set the group apart in the help output.</p>"},{"location":"options/#co-occurring-option-groups","title":"Co-Occurring Option Groups","text":"<p>Sometimes you have a set of options that only make sense when specified together. To enforce this, you can make an option group <code>cooccurring</code>.</p> <p>Co-occurring groups must have at least one <code>required</code> option, and may also have non-required options. The <code>required</code> constraint is enforced if any of the options in the group are given on the command line. If none if the options are given, the value of the group is null.</p> ExampleUsage 1Usage 2Usage 3 <pre><code>class UserOptions : OptionGroup() {\nval name by option().required()\nval age by option().int()\n}\nclass Tool : CliktCommand() {\nval userOptions by UserOptions().cooccurring()\noverride fun run() {\nuserOptions?.let {\necho(it.name)\necho(it.age)\n} ?: echo(\"No user options\")\n}\n}\n</code></pre> <pre><code>$ ./tool\nNo user options\n</code></pre> <pre><code>$ ./tool --name=jane --age=30\njane\n30\n</code></pre> <pre><code>$ ./tool --age=30\nUsage: tool [OPTIONS]\n\nError: Missing option \"--name\".\n</code></pre> <p>Like other option groups, you can specify a <code>name</code> and <code>help</code> text for the group if you want to set the group apart in the help output.</p>"},{"location":"options/#choice-and-switch-options-with-groups","title":"Choice and Switch Options With Groups","text":"<p>If you have different groups of options that only make sense when another option has a certain value, you can use <code>groupChoice</code> and <code>groupSwitch</code>.</p> <p><code>groupChoice</code> options are similar to <code>choice</code> options, but instead of mapping a value to a single new type, they map a value to a co-occurring <code>OptionGroup</code>. Options for groups other than the selected one are ignored, and only the selected group\u2019s <code>required</code> constraints are enforced. In the same way, <code>groupSwitch</code> options are similar to <code>switch</code> options.</p> ExampleUsage 1Usage 2Usage 3Usage 4 <pre><code>sealed class LoadConfig(name: String): OptionGroup(name)\nclass FromDisk : LoadConfig(\"Options for loading from disk\") {\nval path by option().file().required()\nval followSymlinks by option().flag()\n}\n\nclass FromNetwork: LoadConfig(\"Options for loading from network\") {\nval url by option().required()\nval username by option().prompt()\nval password by option().prompt(hideInput = true)\n}\n\nclass Tool : CliktCommand(help = \"An example of a custom help formatter that uses ansi colors\") {\nval load by option().groupChoice(\n\"disk\" to FromDisk(),\n\"network\" to FromNetwork()\n)\n\noverride fun run() {\nwhen(val it = load) {\nis FromDisk -&gt; echo(\"Loading from disk: ${it.path}\")\nis FromNetwork -&gt; echo(\"Loading from network: ${it.url}\")\nnull -&gt; echo(\"Not loading\")\n}\n}\n}\n</code></pre> <pre><code>$ ./tool --load=disk --path=./config --follow-symlinks\nLoading from disk: .\\config\n</code></pre> <pre><code>$ ./tool --load=network --url=www.example.com --username=admin\nPassword: *******\nLoading from network: www.example.com\n</code></pre> <pre><code>$ ./tool --load=disk\nUsage: cli [OPTIONS]\n\nError: Missing option \"--path\".\n</code></pre> <pre><code>$ ./tool --load=whoops\nUsage: cli [OPTIONS]\n\nError: Invalid value for \"--load\": invalid choice: whoops. (choose from disk, network)\n</code></pre>"},{"location":"options/#prompting-for-input","title":"Prompting For Input","text":"<p>In some cases, you might want to create an option that uses the value given on the command line if there is one, but prompt the user for input if one is not provided. Clikt can take care of this for you with the <code>prompt</code> function.</p> ExampleUsage 1Usage 2 <pre><code>class Hello : CliktCommand() {\nval name by option().prompt()\noverride fun run() {\necho(\"Hello $name\")\n}\n}\n</code></pre> <pre><code>./hello --name=foo\nHello foo\n</code></pre> <pre><code>./hello\nName: foo\nHello foo\n</code></pre> <p>The default prompt string is based on the option name, but <code>prompt</code> takes a number of parameters to customize the output.</p>"},{"location":"options/#password-prompts","title":"Password Prompts","text":"<p>You can also create a option that uses a hidden prompt and asks for confirmation. This combination of behavior is commonly used for passwords.</p> ExampleUsage <pre><code>class Login : CliktCommand() {\nval password by option().prompt(requireConfirmation = true, hideInput = true)\noverride fun run() {\necho(\"Your hidden password: $password\")\n}\n}\n</code></pre> <pre><code>$ ./login\nPassword:\nRepeat for confirmation:\nYour hidden password: hunter2\n</code></pre>"},{"location":"options/#eager-options","title":"Eager Options","text":"<p>Sometimes you want an option to halt execution immediately and print a message. For example, the built-on <code>--help</code> option, or the <code>--version</code> option that many programs have. Neither of these options have any value associated with them, and they stop command line parsing as soon as they\u2019re encountered.</p> <p>The <code>--help</code> option is added automatically to commands, and <code>--version</code> can be added using <code>versionOption</code>. Since the option doesn\u2019t have a value, you can\u2019t define it using a property delegate. Instead, call the function on a command directly, either in an <code>init</code> block, or on a command instance.</p> <p>These definitions are equivalent:</p> Version 1Version 2Usage <pre><code>class Cli : NoOpCliktCommand() {\ninit {\nversionOption(\"1.0\")\n}\n}\nfun main(args: Array&lt;String&gt;) = Cli().main(args)\n</code></pre> <pre><code>class Cli : NoOpCliktCommand()\nfun main(args: Array&lt;String&gt;) = Cli().versionOption(\"1.0\").main(args)\n</code></pre> <pre><code>$ ./cli --version\ncli version 1.0\n</code></pre> <p>If you want to define your own option with a similar behavior, you can do so by calling <code>eagerOption</code>. This function takes an <code>action</code> that is called when the option is encountered on the command line. To print a message and halt execution normally from the callback, you can throw a <code>PrintMessage</code> exception, and <code>CliktCommand.main</code> will take care of printing the message. If you want to exit normally without printing a message, you can throw <code>Abort(error=false)</code> instead.</p> <p>You can define your own version option like this:</p> <pre><code>class Cli : NoOpCliktCommand() {\ninit {\neagerOption(\"--version\") {\nthrow PrintMessage(\"$commandName version 1.0\")\n}\n}\n}\n</code></pre>"},{"location":"options/#deprecating-options","title":"Deprecating Options","text":"<p>You can communicate to users that an option is deprecated with <code>option().deprecated()</code>. By default, this function will add a tag to the option\u2019s help message, and print a warning to stderr if the option is used.</p> <p>You can customize or omit the warning message and help tags, or change the warning into an error.</p> ExampleUsage 1Usage 2Usage 3Usage 4Help Output <pre><code>class Cli : CliktCommand() {\nval opt by option(help = \"option 1\").deprecated()\nval opt2 by option(help = \"option 2\").deprecated(\"WARNING: --opt2 is deprecated, use --new-opt instead\", tagName = null)\nval opt3 by option(help = \"option 3\").deprecated(tagName = \"pending deprecation\", tagValue = \"use --new-opt instead\")\nval opt4 by option(help = \"option 4\").deprecated(error = true)\n\noverride fun run() = echo(\"command run\")\n}\n</code></pre> <pre><code>$ ./cli --opt=x\nWARNING: option --opt is deprecated\ncommand run\n</code></pre> <pre><code>$ ./cli --opt2=x\nWARNING: --op2 is deprecated, use --new-opt instead\ncommand run\n</code></pre> <pre><code>$ ./cli --opt3=x\nWARNING: option --opt3 is deprecated\ncommand run\n</code></pre> <pre><code>$ ./cli --opt4=x\nERROR: option --opt4 is deprecated\n</code></pre> <pre><code>$ ./cli --help\nUsage: cli [OPTIONS]\n\nOptions:\n  --opt TEXT   option 1 (deprecated)\n  --opt2 TEXT  option 2\n  --opt3 TEXT  option 3 (pending deprecation: use --new-opt instead)\n  --opt4 TEXT  option 4 (deprecated)\n</code></pre>"},{"location":"options/#unknown-options","title":"Unknown Options","text":"<p>You may want to collect unknown options for manual processing. You can do this by passing <code>treatUnknownOptionsAsArgs = true</code> to your <code>CliktCommand</code> constructor. This will cause Clikt to treat unknown options as positional arguments rather than reporting an error when one is encountered. You\u2019ll need to define an <code>argument().multiple()</code> property to collect the options, otherwise an error will still be reported.</p> ExampleUsage <pre><code>class Wrapper : CliktCommand(treatUnknownOptionsAsArgs = true) {\ninit { context { allowInterspersedArgs = false } }\n\nval command by option(help = \"?\").required()\nval arguments by argument().multiple()\n\noverride fun run() {\nval cmd = (listOf(command) + arguments).joinToString(\" \")\nval proc = Runtime.getRuntime().exec(cmd)\nprintln(proc.inputStream.bufferedReader().readText())\nproc.waitFor()\n}\n}\n</code></pre> <pre><code>$ ./wrapper --command=git tag --help | head -n4\nGIT-TAG(1)                        Git Manual                        GIT-TAG(1)\n\nNAME\n       git-tag - Create, list, delete or verify a tag object signed with GPG\n</code></pre> <p>Note that flag options in a single token (e.g. using <code>-abc</code> to specify <code>-a</code>, <code>-b</code>, and <code>-c</code> in a single token) will still report an error if they are unknown. Each option should be specified separately in this mode.</p> <p>You\u2019ll often want to set <code>allowInterspersedArgs = false</code> on your Context when using <code>treatUnknownOptionsAsArgs</code>. You may also find that subcommands are a better fit than <code>treatUnknownOptionsAsArgs</code> for your use case.</p>"},{"location":"options/#values-from-environment-variables","title":"Values From Environment Variables","text":"<p>Clikt supports reading option values from environment variables if they aren\u2019t given on the command line. This feature is helpful when automating tools. For example, when using <code>git commit</code>, you can set the author date with a command line parameter: <code>git commit --date=10/21/2015</code>. But you can also set it with an environment variable: <code>GIT_AUTHOR_DATE=10/21/2015 git commit</code>.</p> <p>Clikt will read option values from environment variables as long as it has an envvar name for the option. There are two ways to set that name: you can set the name manually for an option, or you can enable automatic envvar name inference.</p> <p>To set the envvar name manually, pass the name to <code>option</code>:</p> ExampleUsage 1Usage 2 <pre><code>class Hello : CliktCommand() {\nval name by option(envvar = \"MY_NAME\")\noverride fun run() {\necho(\"Hello $name\")\n}\n}\n</code></pre> <pre><code>$ export MY_NAME=Foo\n$ ./hello\nHello Foo\n</code></pre> <pre><code>$ export MY_NAME=Foo\n$ ./hello --name=Bar\nHello Bar\n</code></pre> <p>You can enable automatic envvar name inference by setting the <code>autoEnvvarPrefix</code> on a command\u2019s <code>context</code>. This will cause all options without an explicit envvar name to be given an uppercase underscore-separated envvar name. Since the prefix is set on the <code>context</code>, it is propagated to subcommands. If you have a a subcommand called <code>foo</code> with an option <code>--bar</code>, and your prefix is <code>MY_TOOL</code>, the option\u2019s envvar name will be <code>MY_TOOL_FOO_BAR</code>.</p> ExampleUsage <pre><code>class Hello : CliktCommand() {\ninit {\ncontext { autoEnvvarPrefix = \"HELLO\" }\n}\nval name by option()\noverride fun run() {\necho(\"Hello $name\")\n}\n}\n</code></pre> <pre><code>$ export HELLO_NAME=Foo\n$ ./hello\nHello Foo\n</code></pre>"},{"location":"options/#multiple-values-from-environment-variables","title":"Multiple Values from Environment Variables","text":"<p>You might need to allow users to specify multiple values for an option in a single environment variable. You can do this by creating an option with <code>split</code>.</p>"},{"location":"options/#flag-option-values-from-environment-variables","title":"Flag Option Values from Environment Variables","text":"<p>For flag options, any of the following (case-insensitive) environment variable values will be interpreted as <code>true</code>:</p> <ul> <li><code>\"true\"</code>, <code>\"t\"</code>, <code>\"1\"</code>, <code>\"yes\"</code>, <code>\"y\"</code>, <code>\"on\"</code></li> </ul> <p>The following (case-insensitive) values wil be interpreted as <code>false</code>:</p> <ul> <li><code>\"false\"</code>, <code>\"f\"</code>, <code>\"0\"</code>, <code>\"no\"</code>, <code>\"n\"</code>, <code>\"off\"</code></li> </ul> <p>All other values are invalid.</p>"},{"location":"options/#overriding-system-environment-variables","title":"Overriding system environment variables","text":"<p>You can set a custom function that will be used instead of the system environment variables with ContextBuilder.envvarReader.</p> <pre><code>@Test\nfun `test envvar`() {\nval envvars = mapOf(\"MY_TOOL_OPTION\" to \"value\")\nval tool = MyTool().context {\nenvvarReader = { envvars[it] }\n}\ntool.parse(emptyList())\nassertEquals(\"value\", tool.option)\n}\n</code></pre>"},{"location":"options/#values-from-configuration-files","title":"Values from Configuration Files","text":"<p>Clikt also supports reading option values from one or more configuration files (or other sources) when they aren\u2019t present on the command line. For example, when using <code>git commit</code>, you can set the author email with a command line parameter: <code>git commit --author='Clikt &lt;clikt@example.com&gt;</code>. But you can also set it in your git configuration file: <code>user.email=clikt@example.com</code>.</p> <p>Clikt allows you to specify one or more sources of option values that will be read from with the <code>Context.valueSource</code> builder.</p> ExampleUsage <pre><code>class Hello : CliktCommand() {\ninit {\ncontext {\nvalueSource = PropertiesValueSource.from(\"myconfig.properties\")\n}\n}\nval name by option()\noverride fun run() {\necho(\"Hello $name\")\n}\n}\n</code></pre> <pre><code>$ echo \"name=Foo\" &gt; myconfig.properties\n$ ./hello\nHello Foo\n</code></pre> <p>You can also pass multiple sources to <code>Context.valueSources</code>, and each source will be searched for the value in order.</p> <p>Clikt includes support for reading values from a map, and (on JVM) from Java Properties files. For these two sources, you can customize the keys used to look up options by passing the result of <code>ValueSource.getKey</code> or <code>ValueSource.envvarKey</code> to the source\u2019s <code>getKey</code> constructor parameter.</p> <p>You can add any other file type by implementing ValueSource. See the JSON sample for an implementation that uses kotlinx.serialization to load values from JSON files.</p>"},{"location":"options/#configuration-files-and-environment-variables","title":"Configuration Files and Environment Variables","text":"<p>Every option can read values from both environment variables and configuration files. By default, Clikt will use the value from an environment variable before the value from a configuration file, but you can change this by setting <code>Context.readEnvvarBeforeValueSource</code> to <code>false</code>.</p>"},{"location":"options/#windows-and-java-style-option-prefixes","title":"Windows and Java-Style Option Prefixes","text":"<p>When specifying option names manually, you can use any prefix (as long as it\u2019s entirely punctuation).</p> <p>For example, you can make a Windows-style interface with slashes:</p> ExampleUsage <pre><code>class Hello: CliktCommand() {\nval name by option(\"/name\", help=\"your name\")\noverride fun run() {\necho(\"Hello, $name!\")\n}\n}\n</code></pre> <pre><code>$ ./hello /name Foo\nHello, Foo!\n</code></pre> <p>Or you can make a Java-style interface that uses single-dashes for long options:</p> ExampleUsage <pre><code>class Hello: CliktCommand() {\nval name by option(\"-name\", help=\"your name\")\noverride fun run() {\necho(\"Hello, $name!\")\n}\n}\n</code></pre> <pre><code>$ ./hello -name Foo\nHello, Foo!\n</code></pre> <p>Note that inferred names will always have a POSIX-style prefix like <code>--name</code>. If you want to use a different prefix, you should specify all option names manually.</p>"},{"location":"options/#option-transformation-order","title":"Option Transformation Order","text":"<p>Clikt has a large number of extension functions that can modify options. When applying multiple functions to the same option, there\u2019s only one valid order for the functions to be applied. For example, <code>option().default(3).int()</code> will not compile, because <code>default</code> must be applied after the value type conversion. Similarly, you can only apply one transform of each type. So <code>option().int().float()</code> is invalid since <code>int</code> and <code>float</code> both change the value type, as is <code>option().default(\"\").multiple()</code> since <code>default</code> and <code>multiple</code> both transform the call list (if you need a custom default value for <code>multiple</code>, you can pass it one as an argument).</p> <p>Here\u2019s an integer option with one of each available transform in a valid order:</p> <pre><code>val opt: Pair&lt;Int, Int&gt; by option(\"-o\", \"--opt\")\n.int()\n.restrictTo(1..100)\n.pair()\n.default(1 to 2)\n.validate { require(it.second % 2 == 0) }\n</code></pre>"},{"location":"parameters/","title":"Parameters","text":"<p>Clikt supports two types of parameters: options and positional arguments. If you\u2019re following Unix conventions with your interface, you should use options for most parameters. Options are usually optional, and arguments are frequently required.</p>"},{"location":"parameters/#differences","title":"Differences","text":"<p>Arguments have the advantage of being able to accept a variable number of values, while Options are limited to a fixed number of values. Other than that restriction, options have more capabilities than arguments.</p> <p>Options can:</p> <ul> <li>Act as flags (options don\u2019t have to take values)</li> <li>Prompt for missing input</li> <li>Load values from environment variables</li> </ul> <p>In general, arguments are usually used for values like file paths or URLs, or for required values, and options are used for everything else.</p>"},{"location":"parameters/#parameter-names","title":"Parameter Names","text":"<p>Both options and arguments can infer their names (or the metavar in the case of arguments) from the name of the property. You can also specify the names manually. Options can have any number of names, where arguments only have a single metavar.</p> ExampleHelp Output <pre><code>class Cli : CliktCommand() {\nval inferredOpt by option()\nval inferred by argument()\nval explicitOpt by option(\"-e\", \"--explicit\")\nval explicitArg by argument(\"&lt;explicit&gt;\")\noverride fun run() = Unit\n}\n</code></pre> <pre><code>Usage: cli [OPTIONS] INFERRED &lt;explicit&gt;\n\nOptions:\n  --inferred-opt TEXT\n  -e, --explicit TEXT\n  -h, --help           Show this message and exit\n</code></pre>"},{"location":"parameters/#parameter-types","title":"Parameter Types","text":"<p>Both options and arguments can convert the String that the user inputs to other types.</p> <p>Types work by transforming the return value of the property delegate. By default parameters have a string type:</p> <pre><code>val opt: String? by option(help=\"an option\")\nval arg: String by argument(help=\"an argument\")\n</code></pre> <p>To convert the input to an integer, for example, use the <code>int()</code> extension function:</p> <pre><code>val opt: Int? by option(help=\"an option\").int()\nval arg: Int by argument(help=\"an argument\").int()\n</code></pre>"},{"location":"parameters/#built-in-types","title":"Built-In Types","text":"<p>There are a number of built in types that can be applied to options and arguments.</p>"},{"location":"parameters/#int-and-long","title":"Int and Long","text":"<ul> <li><code>option().int()</code> and <code>argument().int()</code></li> <li><code>option().long()</code> and <code>argument().long()</code></li> </ul> <p>By default, any value that fits in the integer type is accepted. You can restrict the values to a range with <code>restrictTo()</code>, which allows you to either clamp the input to the range, or fail with an error if the input is outside the range.</p>"},{"location":"parameters/#float-and-double","title":"Float and Double","text":"<ul> <li><code>option().float()</code> and <code>argument().float()</code></li> <li><code>option().double()</code> and <code>argument().double()</code></li> </ul> <p>As with integers, you can restrict the input to a range with <code>restrictTo()</code>.</p>"},{"location":"parameters/#choice","title":"Choice","text":"<ul> <li><code>option().choice()</code> and <code>argument().choice()</code></li> </ul> <p>You can restrict the values to a set of values, and optionally map the input to a new value. For example, to create an option that only accepts the value \u201cA\u201d or \u201cB\u201d:</p> <pre><code>val opt: String? by option().choice(\"a\", \"b\")\n</code></pre> <p>You can also convert the restricted set of values to a new type:</p> <pre><code>val color: Int? by argument().choice(\"red\" to 1, \"green\" to 2)\n</code></pre> <p>Choice parameters accept values that are case-sensitive by default. This can be configured by passing <code>ignoreCase = true</code>.</p>"},{"location":"parameters/#enum","title":"Enum","text":"<ul> <li><code>option().enum()</code> and <code>argument().enum()</code></li> </ul> <p>Like <code>choice</code>, but uses the values of an enum type.</p> <pre><code>enum class Color { RED, GREEN }\nval color: Color? by option().enum&lt;Color&gt;()\n</code></pre> <p>Enum parameters accept case-insensitive values by default. This can be configured by passing <code>ignoreCase = false</code>.</p>"},{"location":"parameters/#file-paths","title":"File paths","text":"<ul> <li><code>option().file()</code> and <code>argument().file()</code></li> <li><code>option().path()</code> and <code>argument().path()</code></li> </ul> <p>These conversion functions take extra parameters that allow you to require that values are file paths that have certain attributes, such as that they are directories, or they are writable files.</p>"},{"location":"parameters/#file-path-inputstream-and-outputstreams","title":"File path <code>InputStream</code> and <code>OutputStream</code>s","text":"<ul> <li><code>option().inputStream()</code> and <code>argument().inputStream()</code></li> <li><code>option().outputStream()</code> and <code>argument().outputStream()</code></li> </ul> <p>Like file and path, these conversions take file path values, but expose them as open streams for reading or writing. They support the unix convention of passing <code>-</code> to specify stdin or stdout rather than a file on the filesystem. You\u2019ll need to close the streams yourself. You can also use stdin or stdout as their default values.</p> <p>If you need to check if one of these streams is pointing to a file rather than stdin or stdout, you can use <code>isCliktParameterDefaultStdin</code> or <code>isCliktParameterDefaultStdout</code>.</p>"},{"location":"parameters/#custom-types","title":"Custom Types","text":"<p>You can convert parameter values to a custom type by using <code>argument().convert()</code> and <code>option().convert()</code>. These functions take a lambda that converts the input <code>String</code> to any type. If the parameter takes multiple values, or an option appears multiple times in <code>argv</code>, the conversion lambda is called once for each value.</p> <p>Any errors that are thrown from the lambda are automatically caught and a usage message is printed to the user. If you need to trigger conversion failure, you can use <code>fail(\"error message\")</code> instead of raising an exception.</p> <p>For example, you can create an option of type <code>BigDecimal</code> like this:</p> ExampleUsage 1Usage 2 <pre><code>class Cli: CliktCommand() {\nval opt by option().convert { it.toBigDecimal() }\noverride fun run() = echo(\"opt=$opt\")\n}\n</code></pre> <pre><code>$ ./cli --opt=1.5\nopt=1.5\n</code></pre> <pre><code>$ ./cli --opt=foo\nUsage: cli [OPTIONS]\n\nError: Invalid value for \"--opt\": For input string: \"foo\"\n</code></pre>"},{"location":"parameters/#metavars","title":"Metavars","text":"<p>You can also pass <code>option().convert()</code> a metavar that will be printed in the help page instead of the default of <code>VALUE</code>. We can modify the above example to use a metavar and an explicit error message:</p> ExampleUsage 1Usage 2 <pre><code>class Cli: CliktCommand() {\nval opt by option(help=\"a real number\").convert(\"FLOAT\") {\nit.toBigDecimalOrNull() ?: fail(\"A real number is required\")\n}\noverride fun run() = echo(\"opt=$opt\")\n}\n</code></pre> <pre><code>$ ./cli --opt=foo\nUsage: cli [OPTIONS]\n\nError: Invalid value for \"--opt\": A real number is required\n</code></pre> <pre><code>$ ./cli --help\nUsage: cli [OPTIONS]\n\nOptions:\n  --opt FLOAT  a real number\n  -h, --help   Show this message and exit\n</code></pre>"},{"location":"parameters/#chaining","title":"Chaining","text":"<p>You can call <code>convert</code> more than once on the same parameter. This allows you to reuse existing conversion functions. For example, you could automatically read the text of a file parameter.</p> ExampleUsage <pre><code>class FileReader: CliktCommand() {\nval file: String by argument()\n.file(mustExist=true, canBeDir=false)\n.convert { it.readText() }\noverride fun run() {\necho(\"Your file contents: $file\")\n}\n}\n</code></pre> <pre><code>$ echo 'some text' &gt; myfile.txt\n$ ./filereader ./myfile.txt\nYour file contents: some text\n</code></pre>"},{"location":"parameters/#parameter-validation","title":"Parameter Validation","text":"<p>After converting a value to a new type, you can perform additional validation on the converted value with <code>check()</code> and <code>validate()</code> (or the argument equivalents).</p>"},{"location":"parameters/#check","title":"<code>check()</code>","text":"<p><code>check()</code> is similar the stdlib function of the same name: it takes lambda that returns a boolean to indicate if the parameter value is valid or not, and reports an error if it returns false. The lambda is only called if the parameter value is non-null.</p> ExampleUsage 1Usage 2Usage 3 <pre><code>class Tool : CliktCommand() {\nval number by option(help = \"An even number\").int()\n.check(\"value must be even\") { it % 2 == 0 }\n\noverride fun run() {\necho(\"number=$number\")\n}\n}\n</code></pre> <pre><code>$ ./tool --number=2\nnumber=2\n</code></pre> <pre><code>$ ./tool\nnumber=null\n</code></pre> <pre><code>$ ./tool --number=1\nUsage: tool [OPTIONS]\n\nError: invalid value for --number: value must be even\n</code></pre>"},{"location":"parameters/#validate","title":"<code>validate()</code>","text":"<p>For more complex validation, you can use <code>validate()</code>. This function takes a lambda that returns nothing, but can call <code>fail(\"error message\")</code> if the value is invalid. You can also call <code>require()</code>, which will fail if the provided expression is false. Like <code>check</code>, the lambda is only called if the value is non-null.</p> <p>The lambdas you pass to <code>validate</code> are called after the values for all options and arguments have been set, so (unlike in transforms) you can reference other parameters:</p> ExampleUsage 1Usage 2 <pre><code>class Tool : CliktCommand() {\nval number by option().int().default(0)\nval biggerNumber by option().int().validate {\nrequire(it &gt; number) {\n\"--bigger-number must be bigger than --number\"\n}\n}\n\noverride fun run() {\necho(\"number=$number, biggerNumber=$biggerNumber\")\n}\n}\n</code></pre> <pre><code>$ ./tool --number=1\nnumber=1, biggerNumber=null\n</code></pre> <pre><code>$ ./tool --number=1 --bigger-number=0\nUsage: tool [OPTIONS]\n\nError: --bigger-number must be bigger than --number\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>You can get the library using any maven-compatible build system. Installation instructions can be found in the README.</p>"},{"location":"quickstart/#basic-concepts","title":"Basic Concepts","text":"<p>Clikt command line interfaces are created by using property delegates inside of a CliktCommand. The normal way to use Clikt is to forward <code>argv</code> from your <code>main</code> function to CliktCommand.main.</p> <p>The simplest command with no parameters would look like this:</p> <pre><code>class Hello: CliktCommand() {\noverride fun run() {\necho(\"Hello World!\")\n}\n}\n\nfun main(args: Array&lt;String&gt;) = Hello().main(args)\n</code></pre> <p>And what it looks like to use:</p> <pre><code>$ ./hello\nHello World!\n</code></pre> <p>A help page is generated automatically:</p> <pre><code>$ ./hello --help\nUsage: hello [OPTIONS]\n\nOptions:\n  -h, --help  Show this message and exit\n</code></pre>"},{"location":"quickstart/#printing-to-stdout-and-stderr","title":"Printing to Stdout and Stderr","text":"<p>Why does this example use echo instead of println? Although <code>println</code> works, it can cause problems with multi-platform support. echo automatically translates line breaks into the line separator for the current platform. So you don\u2019t have to worry that some of your users will see mangled output because you didn\u2019t test on Windows. You can also pass <code>err=true</code> to <code>echo</code> to print to stderr instead of stdout.</p>"},{"location":"quickstart/#nesting-commands","title":"Nesting Commands","text":"<p>Instances of any command can be attached to other commands, allowing arbitrary nesting of commands. For example, you could write a script to manage a database:</p> ExampleUsageHelp Output <pre><code>class Database: CliktCommand() {\noverride fun run() = Unit\n}\n\nclass Init: CliktCommand(help=\"Initialize the database\") {\noverride fun run() {\necho(\"Initialized the database.\")\n}\n}\n\nclass Drop: CliktCommand(help=\"Drop the database\") {\noverride fun run() {\necho(\"Dropped the database.\")\n}\n}\n\nfun main(args: Array&lt;String&gt;) = Database()\n.subcommands(Init(), Drop())\n.main(args)\n</code></pre> <pre><code>$ ./db init\nInitialized the database.\n</code></pre> <pre><code>$ ./db --help\nUsage: database [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  -h, --help  Show this message and exit\n\nCommands:\n  init  Initialize the database\n  drop  Drop the database\n</code></pre>"},{"location":"quickstart/#adding-parameters","title":"Adding Parameters","text":"<p>To add parameters, use the option and argument property delegates:</p> ExampleHelp Output <pre><code>class Hello : CliktCommand() {\nval count by option(help=\"Number of greetings\").int().default(1)\nval name by argument()\n\noverride fun run() {\nfor (i in 1..count) {\necho(\"Hello $name!\")\n}\n}\n}\n</code></pre> <pre><code>$ ./hello --help\nUsage: hello [OPTIONS] NAME\n\nOptions:\n  --count INT  Number of greetings\n  -h, --help   Show this message and exit\n</code></pre>"},{"location":"quickstart/#developing-command-line-applications-with-gradle","title":"Developing Command Line Applications With Gradle","text":"<p>When you write a command line application, you probably want to be able to run it without invoking <code>java -jar ...</code> every time. If you\u2019re using Gradle, the application plugin provides a gradle task that bundles your program jars and scripts to launch them. It makes it easy to build a zip or tarball that you can distribute to your users without them needing to perform any incantations like setting up a classpath. You can see this plugin in use the in Clikt samples.</p> <p>The application plugin also creates tasks that will build then run your main function directly from within gradle. Although it seems like these tasks would make development easier, they are not recommended for use with command line programs. Unfortunately, due to the way gradle is designed, command line arguments are not visible to the task. Although you can hack the task to split up a gradle property and pass it in to your argv, this approach is limited. Additionally, stdin, stdout, and environment variables are all captured by gradle. All these limitations make the run task mostly useless for command line applications.</p> <p>An easier way to do development is to use the <code>installDist</code> task provided by the plugin. This builds all the distribution scripts in your build folder, which you can then execute normally. See Clikt\u2019s runsample script for an example of this approach.</p>"},{"location":"utilities/","title":"Utilities","text":"<p>Writing command line interfaces often involves more than just parsing the command line. Clikt also provides functions to perform actions commonly used in command line programs.</p>"},{"location":"utilities/#launching-editors","title":"Launching Editors","text":"<p>If you need to ask users for multi-line input, or need to have the user edit a file, you can do so through <code>editText</code> and <code>editFile</code>. These functions open the program defined in the <code>VISUAL</code> or <code>EDITOR</code> environment variables, or a sensible default if neither are defined. The functions return the edited text if the user saved their changes.</p> Example <pre><code>fun getCommitMessage(): String? {\nval message = \"\"\"\n    # Enter your message.\n    # Lines starting with # are ignored\n    \"\"\".trimIndent()\nreturn editText(message, requireSave = true)\n?.replace(Regex(\"#[^\\n]*\\n\"), \"\")\n}\n</code></pre>"},{"location":"utilities/#input-prompts","title":"Input Prompts","text":"<p>Options can prompt for values automatically, but you can also do so manually with <code>prompt</code>. By default, it accepts any input string, but you can also pass in a conversion function. If the conversion raises a <code>UsageError</code>, the prompt will ask the user to enter a different value.</p> ExampleInteractive Session <pre><code>val input = prompt(\"Enter a number\") {\nit.toIntOrNull() ?: throw UsageError(\"$it is not a valid integer\")\n}\necho(\"Twice your number is ${input * 2}\")\n</code></pre> <pre><code>Enter a number: foo\nError: foo is not a valid integer\nEnter a number: 11\nTwice your number is 22\n</code></pre>"},{"location":"utilities/#confirmation-prompts","title":"Confirmation Prompts","text":"<p>You can also ask the user for a yes or no response with <code>confirm</code>:</p> <pre><code>if (confirm(\"Continue?\") == true) {\necho(\"OK!\")\n}\n</code></pre> <p>If you simply want to abort the program in the user gives a negative response, you can pass <code>abort=true</code>:</p> <pre><code>confirm(\"Continue?\", abort=true)\n</code></pre>"},{"location":"whyclikt/","title":"Why Clikt?","text":"<p>There are existing Kotlin libraries for creating command line interfaces, and many Java libraries work in Kotlin as well. However, none of them had all of the following features:</p> <ul> <li>Unrestricted composability of commands</li> <li>Fully static type safety for parameters</li> <li>Composable parameter customization that doesn\u2019t require registering converter objects.</li> <li>Full support for Unix command line conventions</li> <li>Capable of reading parameter values from environment variables out of the box</li> <li>Included support for common functionality (keyboard interactivity, line ending normalization, launching editors, etc.)</li> <li>Built-in support for multi-token command aliases</li> </ul> <p>Clikt is focused on making writing robust, posix-compliant command line interfaces as easy as possible. A good CLI does more than just parse <code>argv</code>. It allows users to specify values in environment variables, and in some cases prompts for additional input, or opens an editor. Clikt supports all of this out of the box.</p> <p>Some times you need to make a CLI that doesn\u2019t follow Unix conventions. You might be writing for windows, or you want to use the Java style of long options with a single dash. Maybe you need to use a bunch of required options instead of arguments, or you want the help page formatted differently. \u201cBest practices\u201d might not be the best for you, so Clikt tries to make implementing uncommon use-cases as easy as possible.</p>"},{"location":"whyclikt/#why-not-a-kotlin-library-like-kotlin-argparser-or-kotlinxcli","title":"Why not a Kotlin library like kotlin-argparser or kotlinx.cli?","text":"<p>Clikt isn\u2019t the only Kotlin CLI library. kotlin-argparser and kotlinx.cli both predate Clikt\u2019s creation.</p> <p>Both, like Clikt, use property delegates to define parameters, but they\u2019re missing most of Clikt features and its extensible design.</p> <p>kotlinx.cli was written by JetBrains and mostly copied kotlin-argparser\u2018s design (and, later, some of Clikt\u2019s).</p> <p>kotlin-argparser works well for simple cases. It\u2019s missing a lot of features that Clikt has, but features could be added. Its real drawback is that it fundamentally does not support composition of commands or parameter values. The lack of subcommand support was already a non-starter, but there are other design decisions that make it unsuitable.</p> <p>In the simple cases, the two libraries are similar. Here\u2019s an example from its README:</p> <pre><code>class MyArgs(parser: ArgParser) {\nval v: Boolean by parser.flagging(help=\"enable verbose mode\")\nval username: String? by parser.storing(help=\"name of the user\")\nval count: Int? by parser.storing(help=\"number of the widgets\") { toInt() }\nval source: List&lt;String&gt; by parser.positionalList(help=\"source filenames\")\nval destination: String by parser.positional(help=\"destination\")\n}\n\nfun main(args: Array&lt;String&gt;) = mainBody {\nArgParser(args).parseInto(::MyArgs).run {\nprintln(\"Hello, $username!\")\nprintln(\"Moving $count widgets from $source to $destination.\")\n}\n}\n</code></pre> <p>Here\u2019s the same thing with Clikt:</p> <pre><code>class Cli : CliktCommand() {\nval v: Boolean by option(help = \"enable verbose mode\").flag()\nval username: String? by option(help = \"name of the user\")\nval count: Int? by option(help = \"number of the widgets\").int()\nval source: List&lt;String&gt; by argument(help = \"source filenames\").multiple()\nval destination: String by argument(help = \"destination\")\noverride fun run() {\nprintln(\"Hello, $name!\")\nprintln(\"Moving $count widgets from $source to $destination.\")\n}\n}\n\nfun main(args: Array&lt;String&gt;) = Cli().main(args)\n</code></pre> <p>Both work fine, although you may find Clikt more consistent and a bit less verbose. The differences become more pronounced once you try to do anything that isn\u2019t built in to kotlin-argparser.</p> <p>Maybe you need an option to take two values. Here\u2019s another example from the <code>kotlin-argparser</code> README showing how to do that:</p> <pre><code>fun ArgParser.putting(vararg names: String, help: String) =\noption&lt;MutableMap&lt;String, String&gt;&gt;(*names,\nargNames = listOf(\"KEY\", \"VALUE\"),\nhelp = help) {\nvalue.orElse { mutableMapOf&lt;String, String&gt;() }.apply {\nput(arguments.first(), arguments.last()) }\n}\n\nfun ArgParser.putting(help: String) =\nArgParser.DelegateProvider { identifier -&gt;\nputting(identifierToOptionName(identifier), help = help) }\n\nclass MyArgs(parser: ArgParser) {\nval v by parser.putting(help=\"this takes two values\")\n}\n</code></pre> <p>Clikt has that functionality built in as <code>option().pair()</code>, but you could implement it yourself like this:</p> <pre><code>class Cli : CliktCommand() {\nval v by option(help=\"this takes two values\").transformValues(2) { it[0] to it[1] }\n}\n</code></pre> <p>The Clikt version is of course much simpler, but there are more fundamental issues with the <code>kotlin-argparser</code> version that drove the creation of Clikt:</p> <ul> <li>Its inheritance-based design means that if you wanted to change the type of each value, you would have to copy all of the code for each type. With Clikt, you could just do <code>option().int().transformValues(2) { it[0] to it[1] }</code></li> <li>Its inheritance-based design means that supporting types, multiple values, and multiple option occurrences would require a combinatorial number of copies of the above code. With Clikt, these are all orthogonal.</li> <li>You have to do all error checking yourself. The <code>argparser</code> example silently discards extra values, or copies the single value, rather than inform the user of the mistake. You could write more code to do so, but Clikt takes care of it for you.</li> <li>Option name inference is not automatic, requiring you to wrap the delegate with yet another function.</li> <li>Each delegate function has a different name, with no indication of whether its creating an option or positional argument. With Clikt, all options are created with <code>option()</code>, and all arguments with <code>argument()</code>.</li> </ul> <p>Some of these problems can be solved by writing more code, and some can\u2019t. On the other hand, Clikt attempts to have a consistent, intuitive, composable design that does the right thing without forcing you to think about edge cases.</p>"},{"location":"whyclikt/#why-not-a-java-library-like-jcommander-or-picocli","title":"Why not a Java library like JCommander or Picocli?","text":"<p>There are a lot of command line libraries for Java. Most are verbose and not composable. Two popular Java libraries that are usable from Kotlin are JCommander and picocli.</p> <p>These libraries use annotations to define parameters, and reflection to set fields. This is functional for simple types, but defining your own types requires you to register a type adapter with the library. This means that type errors are not caught until runtime, and many types of customization are not possible.</p> <p>For example, in JCommander, options that take multiple values cannot be converted to other types. The JCommander docs explain:</p> <p>\u2026 only List is allowed for parameters that define an arity. You will have to convert these values yourself if the parameters you need are of type Integer or other (this limitation is due to Java\u2019s erasure). <p>You also can\u2019t customize many aspects of parsing in JCommander. It can\u2019t infer parameter names. With JCommander, you can\u2019t have an option with multiple values and multiple occurrences at the same time. You can\u2019t have more than one argument, and it can only take one value or an unlimited number of values. You can\u2019t nest subcommands.</p> <p>JCommander and piocli are great libraries if you\u2019re writing code in Java, but we can do much better with Kotlin.</p>"}]}